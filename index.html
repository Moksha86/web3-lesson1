<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web3 Odyssey - Module 1: Lesson 1.1 | MOKSHA Innovators Guild</title>
    <link rel="icon" href="favicon.png" type="image/png">
    
     Google Fonts 
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;700&family=Roboto:wght@300;400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        /* CSS Custom Properties for Consistent Theming */
        :root {
            --primary-bg: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 25%, #2d1b69 50%, #1e1e3f 75%, #0f0f23 100%);
            --secondary-bg: rgba(30, 30, 63, 0.8);
            --accent-cyan: #00ffff;
            --accent-violet: #8a2be2;
            --accent-neon: #39ff14;
            --text-primary: #ffffff;
            --text-secondary: #b8b8d4;
            --text-muted: #8888aa;
            --code-bg: #1a1a2e;
            --border-glow: rgba(0, 255, 255, 0.3);
            --shadow-glow: 0 0 20px rgba(0, 255, 255, 0.1);
            --font-title: 'Roboto Slab', serif;
            --font-body: 'Roboto', sans-serif;
            --font-code: 'Roboto Mono', monospace;
        }

        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: var(--primary-bg);
            background-attachment: fixed;
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Header Styles */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-glow);
            box-shadow: var(--shadow-glow);
            padding: 15px 30px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            height: 60px;
            width: auto;
            filter: drop-shadow(0 0 10px var(--accent-cyan));
        }

        .course-info {
            text-align: right;
        }

        .course-title {
            font-family: var(--font-title);
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-cyan);
            text-shadow: 0 0 10px var(--accent-cyan);
            margin-bottom: 5px;
        }

        .course-subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
            font-weight: 300;
        }

        /* Main Container */
        .main-container {
            max-width: 1100px;
            margin: 120px auto 0;
            padding: 40px;
            background: var(--secondary-bg);
            border-radius: 20px;
            box-shadow: var(--shadow-glow);
            border: 1px solid var(--border-glow);
            backdrop-filter: blur(15px);
        }

        /* Slide Styles */
        .slide {
            margin-bottom: 60px;
            padding: 40px;
            background: rgba(26, 26, 46, 0.6);
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .slide h2 {
            font-family: var(--font-title);
            font-size: 2.2rem;
            font-weight: 700;
            color: var(--accent-cyan);
            text-shadow: 0 0 15px var(--accent-cyan);
            margin-bottom: 30px;
            text-align: center;
            border-bottom: 2px solid var(--accent-violet);
            padding-bottom: 15px;
        }

        .slide-image {
            width: 80%;
            max-width: 600px;
            height: auto;
            display: block;
            margin: 30px auto;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.3);
            border: 2px solid var(--accent-violet);
        }

        .slide-content {
            font-size: 1.1rem;
            line-height: 1.8;
            color: var(--text-primary);
            margin-bottom: 25px;
        }

        .slide-content p {
            margin-bottom: 20px;
        }

        /* Code Block Styles */
        .code-block {
            background: var(--code-bg);
            border: 1px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 20px;
            margin: 25px 0;
            overflow-x: auto;
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.1);
        }

        .code-block pre {
            font-family: var(--font-code);
            font-size: 0.9rem;
            color: var(--accent-neon);
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .code-block code {
            font-family: var(--font-code);
            color: var(--accent-neon);
        }

        /* Table Styles */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: rgba(26, 26, 46, 0.8);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        .comparison-table th {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet));
            color: var(--text-primary);
            font-family: var(--font-title);
            font-weight: 700;
            padding: 15px;
            text-align: center;
            font-size: 1.1rem;
        }

        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            color: var(--text-primary);
            vertical-align: top;
        }

        .comparison-table tr:nth-child(even) {
            background: rgba(0, 255, 255, 0.05);
        }

        /* Quiz Styles */
        .quiz-section {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(0, 255, 255, 0.1));
            border: 2px solid var(--accent-violet);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .quiz-title {
            font-family: var(--font-title);
            font-size: 1.4rem;
            color: var(--accent-violet);
            margin-bottom: 15px;
            text-shadow: 0 0 10px var(--accent-violet);
        }

        .quiz-question {
            font-weight: 500;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .quiz-options {
            list-style: none;
            padding-left: 0;
        }

        .quiz-options li {
            margin: 10px 0;
            padding: 10px 15px;
            background: rgba(26, 26, 46, 0.6);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quiz-options li:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        /* Blockquote Styles */
        .highlight-box {
            background: rgba(0, 255, 255, 0.1);
            border-left: 4px solid var(--accent-cyan);
            padding: 20px;
            margin: 25px 0;
            border-radius: 0 10px 10px 0;
            font-style: italic;
            color: var(--text-secondary);
        }

        /* Link Styles */
        a {
            color: var(--accent-cyan);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        a:hover {
            color: var(--accent-neon);
            text-shadow: 0 0 5px var(--accent-neon);
        }

        /* Footer Styles */
        .footer {
            text-align: center;
            padding: 40px 20px;
            margin-top: 60px;
            border-top: 1px solid var(--border-glow);
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                padding: 15px 20px;
                text-align: center;
            }

            .course-info {
                text-align: center;
                margin-top: 10px;
            }

            .course-title {
                font-size: 1.4rem;
            }

            .course-subtitle {
                font-size: 0.9rem;
            }

            .main-container {
                margin-top: 140px;
                padding: 20px;
            }

            .slide {
                padding: 25px;
                margin-bottom: 40px;
            }

            .slide h2 {
                font-size: 1.8rem;
            }

            .slide-image {
                width: 95%;
            }

            .slide-content {
                font-size: 1rem;
            }

            .comparison-table {
                font-size: 0.9rem;
            }

            .comparison-table th,
            .comparison-table td {
                padding: 10px;
            }
        }

        @media (max-width: 480px) {
            .logo {
                height: 45px;
            }

            .course-title {
                font-size: 1.2rem;
            }

            .course-subtitle {
                font-size: 0.8rem;
            }

            .slide h2 {
                font-size: 1.5rem;
            }

            .slide-content {
                font-size: 0.95rem;
            }

            .code-block {
                padding: 15px;
            }

            .code-block pre {
                font-size: 0.8rem;
            }
        }

        /* Animation for smooth scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Glow effects for interactive elements */
        .slide:hover {
            box-shadow: 0 15px 40px rgba(0, 255, 255, 0.15);
            transform: translateY(-2px);
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
     Fixed Header 
    <header class="header">
        <img src="logo.png" alt="MOKSHA Innovators Guild Logo" class="logo">
        <div class="course-info">
            <div class="course-title">Web3 Odyssey</div>
            <div class="course-subtitle">Module 1: Foundations | Lesson 1.1 Symmetric vs Asymmetric Cryptography</div>
        </div>
    </header>

     Main Content Container 
    <main class="main-container">
        
         Slide 1: Introduction & Objectives 
        <section class="slide">
            <h2>🚀 Welcome to Cryptography Fundamentals</h2>
            <img src="img1.png" alt="Cryptography Introduction" class="slide-image">
            
            <div class="slide-content">
                <p>Welcome to the foundational lesson of Web3 Odyssey! Cryptography is the backbone of blockchain technology, digital currencies, and decentralized applications. In this comprehensive lesson, we'll explore the two fundamental approaches to encryption that power the modern digital world.</p>
                
                <p>Understanding the difference between symmetric and asymmetric cryptography is crucial for any Web3 developer. These cryptographic methods secure everything from your cryptocurrency wallet to smart contract interactions, from secure messaging to digital identity verification.</p>
                
                <p>By the end of this lesson, you'll have a deep understanding of how these cryptographic systems work, their strengths and weaknesses, and most importantly, how they're applied in real-world Web3 scenarios. We'll dive into practical code examples, analyze security implications, and explore the mathematical foundations that make these systems secure.</p>

                <div class="highlight-box">
                    <strong>Learning Objectives:</strong><br>
                    • Understand the fundamental principles of symmetric and asymmetric encryption<br>
                    • Implement both encryption types using Node.js<br>
                    • Analyze the security trade-offs and use cases for each approach<br>
                    • Apply cryptographic concepts to Web3 development scenarios<br>
                    • Evaluate the role of cryptography in blockchain consensus mechanisms
                </div>
            </div>

            <div class="quiz-section">
                <div class="quiz-title">🧠 Quick Check</div>
                <div class="quiz-question">What is the primary purpose of cryptography in Web3 applications?</div>
                <ul class="quiz-options">
                    <li>A) To make applications run faster</li>
                    <li>B) To secure data and verify identities</li>
                    <li>C) To reduce storage requirements</li>
                    <li>D) To improve user interface design</li>
                </ul>
            </div>
        </section>

         Slide 2: Symmetric Encryption Theory 
        <section class="slide">
            <h2>🔐 Symmetric Encryption: The Shared Secret</h2>
            <img src="img2.png" alt="Symmetric Encryption Diagram" class="slide-image">
            
            <div class="slide-content">
                <p>Symmetric encryption, also known as secret-key cryptography, uses a single key for both encryption and decryption operations. This approach is like having a single key that both locks and unlocks a treasure chest. The same key that scrambles your data is the exact same key needed to unscramble it.</p>
                
                <p>The fundamental principle relies on mathematical operations that are easily reversible when you have the key, but computationally infeasible to reverse without it. Modern symmetric algorithms like AES (Advanced Encryption Standard) use complex substitution and permutation operations across multiple rounds to achieve this security.</p>
                
                <p>AES, adopted as a standard by the U.S. government in 2001, operates on 128-bit blocks of data and supports key sizes of 128, 192, or 256 bits. The algorithm performs 10, 12, or 14 rounds respectively, with each round involving four main operations: SubBytes (substitution), ShiftRows (permutation), MixColumns (linear transformation), and AddRoundKey (XOR with round key).</p>

                <p>ChaCha20, developed by Daniel J. Bernstein, represents a more modern approach to symmetric encryption. It's a stream cipher that generates a keystream which is XORed with the plaintext. ChaCha20 is particularly notable for its performance on software implementations and its resistance to timing attacks, making it ideal for mobile and embedded applications.</p>

                <div class="highlight-box">
                    <strong>Key Characteristics:</strong><br>
                    • Single key for encryption and decryption<br>
                    • Fast computation and low resource requirements<br>
                    • Key distribution challenge (how to securely share the key)<br>
                    • Perfect for bulk data encryption<br>
                    • Vulnerable to key compromise (if key is stolen, all data is compromised)
                </div>
            </div>

            <div class="quiz-section">
                <div class="quiz-title">🧠 Knowledge Check</div>
                <div class="quiz-question">How many rounds does AES-256 perform during encryption?</div>
                <ul class="quiz-options">
                    <li>A) 10 rounds</li>
                    <li>B) 12 rounds</li>
                    <li>C) 14 rounds</li>
                    <li>D) 16 rounds</li>
                </ul>
            </div>
        </section>

         Slide 3: Symmetric Encryption Code Example 
        <section class="slide">
            <h2>💻 Implementing Symmetric Encryption in Node.js</h2>
            <img src="img3.png" alt="Node.js Symmetric Encryption Code" class="slide-image">
            
            <div class="slide-content">
                <p>Let's implement AES-256-GCM encryption in Node.js. GCM (Galois/Counter Mode) provides both confidentiality and authenticity, making it ideal for secure communications. This mode combines the counter mode of encryption with Galois mode of authentication.</p>
                
                <p>The following implementation demonstrates key generation, encryption, and decryption processes. Notice how we handle the initialization vector (IV) and authentication tag, both crucial for security. The IV ensures that the same plaintext produces different ciphertexts, while the authentication tag prevents tampering.</p>

                <div class="code-block">
                    <pre><code>const crypto = require('crypto');

class SymmetricCrypto {
    constructor() {
        this.algorithm = 'aes-256-gcm';
        this.keyLength = 32; // 256 bits
        this.ivLength = 16;  // 128 bits
    }

    // Generate a cryptographically secure random key
    generateKey() {
        return crypto.randomBytes(this.keyLength);
    }

    // Encrypt data using AES-256-GCM
    encrypt(plaintext, key) {
        try {
            // Generate random IV for each encryption
            const iv = crypto.randomBytes(this.ivLength);
            
            // Create cipher instance
            const cipher = crypto.createCipher(this.algorithm, key);
            cipher.setAAD(Buffer.from('MOKSHA-WEB3-ODYSSEY', 'utf8'));
            
            // Encrypt the data
            let encrypted = cipher.update(plaintext, 'utf8', 'hex');
            encrypted += cipher.final('hex');
            
            // Get authentication tag
            const authTag = cipher.getAuthTag();
            
            return {
                encrypted,
                iv: iv.toString('hex'),
                authTag: authTag.toString('hex')
            };
        } catch (error) {
            throw new Error(`Encryption failed: ${error.message}`);
        }
    }

    // Decrypt data using AES-256-GCM
    decrypt(encryptedData, key) {
        try {
            const { encrypted, iv, authTag } = encryptedData;
            
            // Create decipher instance
            const decipher = crypto.createDecipher(this.algorithm, key);
            decipher.setAAD(Buffer.from('MOKSHA-WEB3-ODYSSEY', 'utf8'));
            decipher.setAuthTag(Buffer.from(authTag, 'hex'));
            
            // Decrypt the data
            let decrypted = decipher.update(encrypted, 'hex', 'utf8');
            decrypted += decipher.final('utf8');
            
            return decrypted;
        } catch (error) {
            throw new Error(`Decryption failed: ${error.message}`);
        }
    }
}

// Example usage
const symmetricCrypto = new SymmetricCrypto();
const key = symmetricCrypto.generateKey();
const message = "Welcome to Web3 Odyssey! This is a secret message.";

console.log('Original message:', message);

// Encrypt the message
const encryptedResult = symmetricCrypto.encrypt(message, key);
console.log('Encrypted:', encryptedResult);

// Decrypt the message
const decryptedMessage = symmetricCrypto.decrypt(encryptedResult, key);
console.log('Decrypted:', decryptedMessage);

// Demonstrate key sensitivity
try {
    const wrongKey = crypto.randomBytes(32);
    symmetricCrypto.decrypt(encryptedResult, wrongKey);
} catch (error) {
    console.log('Wrong key error:', error.message);
}</code></pre>
                </div>

                <p>This implementation showcases several important security practices: using a cryptographically secure random number generator for keys and IVs, implementing authenticated encryption to prevent tampering, and proper error handling to avoid information leakage through error messages.</p>

                <p>The Additional Authenticated Data (AAD) parameter adds an extra layer of security by including metadata that must match during decryption. This prevents attacks where an adversary might try to use encrypted data in a different context.</p>
            </div>
        </section>

         Slide 4: Symmetric Pros & Cons Table 
        <section class="slide">
            <h2>⚖️ Symmetric Encryption: Advantages & Limitations</h2>
            <img src="img4.png" alt="Symmetric Encryption Analysis" class="slide-image">
            
            <div class="slide-content">
                <p>Understanding the trade-offs of symmetric encryption is crucial for making informed architectural decisions in Web3 applications. While symmetric encryption excels in performance and simplicity, it faces significant challenges in key management and scalability.</p>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Advantages</th>
                            <th>Limitations</th>
                            <th>Web3 Impact</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>High Performance:</strong> Extremely fast encryption/decryption, suitable for large data volumes</td>
                            <td><strong>Key Distribution Problem:</strong> Securely sharing keys between parties is challenging</td>
                            <td>Perfect for encrypting blockchain state data and transaction pools</td>
                        </tr>
                        <tr>
                            <td><strong>Low Resource Usage:</strong> Minimal CPU and memory requirements</td>
                            <td><strong>Scalability Issues:</strong> N parties need N(N-1)/2 keys for full connectivity</td>
                            <td>Enables efficient encryption in resource-constrained IoT devices</td>
                        </tr>
                        <tr>
                            <td><strong>Simple Implementation:</strong> Straightforward to implement and understand</td>
                            <td><strong>No Non-repudiation:</strong> Cannot prove who created a message</td>
                            <td>Cannot be used alone for digital signatures in smart contracts</td>
                        </tr>
                        <tr>
                            <td><strong>Strong Security:</strong> AES-256 is quantum-resistant for foreseeable future</td>
                            <td><strong>Key Compromise Risk:</strong> Single key compromise affects all communications</td>
                            <td>Requires careful key rotation strategies in long-lived dApps</td>
                        </tr>
                        <tr>
                            <td><strong>Standardized Algorithms:</strong> Well-tested, widely adopted standards</td>
                            <td><strong>No Forward Secrecy:</strong> Past communications vulnerable if key is compromised</td>
                            <td>Must be combined with key exchange protocols for secure channels</td>
                        </tr>
                    </tbody>
                </table>

                <p>In Web3 contexts, symmetric encryption is often used in hybrid systems where asymmetric cryptography handles key exchange, and symmetric encryption handles the bulk data encryption. This approach leverages the strengths of both systems while mitigating their individual weaknesses.</p>

                <div class="highlight-box">
                    <strong>Real-World Web3 Applications:</strong><br>
                    • Encrypting private keys in cryptocurrency wallets<br>
                    • Securing off-chain data in Layer 2 solutions<br>
                    • Protecting sensitive smart contract parameters<br>
                    • Encrypting communication channels in decentralized messaging apps<br>
                    • Securing backup and recovery mechanisms
                </div>
            </div>
        </section>

         Slide 5: Asymmetric Encryption Theory 
        <section class="slide">
            <h2>🔑 Asymmetric Encryption: The Mathematical Marvel</h2>
            <img src="img5.png" alt="Asymmetric Encryption Diagram" class="slide-image">
            
            <div class="slide-content">
                <p>Asymmetric encryption, also known as public-key cryptography, revolutionized digital security by solving the key distribution problem. This system uses a mathematically related pair of keys: a public key that can be freely shared and a private key that must be kept secret. The mathematical relationship ensures that data encrypted with one key can only be decrypted with the other.</p>
                
                <p>The security of asymmetric encryption relies on mathematical problems that are easy to compute in one direction but computationally infeasible to reverse without additional information. RSA encryption, for example, is based on the difficulty of factoring large composite numbers into their prime factors. While it's easy to multiply two large primes together, finding those primes from their product is extraordinarily difficult.</p>
                
                <p>Elliptic Curve Cryptography (ECC) represents a more modern approach, offering equivalent security to RSA with much smaller key sizes. ECC is based on the discrete logarithm problem over elliptic curves. The mathematical elegance of elliptic curves allows for the same security level as RSA-2048 with just a 256-bit key, making it ideal for mobile and embedded applications.</p>

                <p>The elliptic curve used in Bitcoin and Ethereum, secp256k1, is defined by the equation y² = x³ + 7 over a finite field. Points on this curve form a mathematical group where the "addition" operation has special properties that make the discrete logarithm problem particularly hard to solve, even with quantum computers using Shor's algorithm.</p>

                <div class="highlight-box">
                    <strong>Mathematical Foundation:</strong><br>
                    • RSA: Based on integer factorization problem<br>
                    • ECC: Based on elliptic curve discrete logarithm problem<br>
                    • Key Generation: Mathematical functions create related key pairs<br>
                    • One-way Functions: Easy to compute forward, hard to reverse<br>
                    • Trapdoor Functions: Easy to reverse with secret information (private key)
                </div>

                <p>The beauty of asymmetric cryptography lies in its dual functionality. Not only can it provide confidentiality (encryption), but it also enables digital signatures for authentication and non-repudiation. When you sign a message with your private key, anyone can verify the signature using your public key, proving that the message came from you and hasn't been tampered with.</p>
            </div>

            <div class="quiz-section">
                <div class="quiz-title">🧠 Mathematical Challenge</div>
                <div class="quiz-question">What mathematical problem underlies the security of Elliptic Curve Cryptography?</div>
                <ul class="quiz-options">
                    <li>A) Integer factorization problem</li>
                    <li>B) Discrete logarithm problem over elliptic curves</li>
                    <li>C) Traveling salesman problem</li>
                    <li>D) Boolean satisfiability problem</li>
                </ul>
            </div>
        </section>

         Slide 6: Asymmetric Encryption Code Example 
        <section class="slide">
            <h2>🛠️ Implementing Asymmetric Encryption in Node.js</h2>
            <img src="img6.png" alt="Node.js Asymmetric Encryption Code" class="slide-image">
            
            <div class="slide-content">
                <p>Let's implement both RSA and Elliptic Curve cryptography in Node.js. This implementation will demonstrate key generation, encryption/decryption, and digital signatures. We'll use the built-in crypto module which provides robust implementations of these algorithms.</p>

                <div class="code-block">
                    <pre><code>const crypto = require('crypto');

class AsymmetricCrypto {
    constructor() {
        this.rsaKeyOptions = {
            modulusLength: 2048,
            publicKeyEncoding: {
                type: 'spki',
                format: 'pem'
            },
            privateKeyEncoding: {
                type: 'pkcs8',
                format: 'pem'
            }
        };
        
        this.eccKeyOptions = {
            namedCurve: 'secp256k1', // Same curve used by Bitcoin/Ethereum
            publicKeyEncoding: {
                type: 'spki',
                format: 'pem'
            },
            privateKeyEncoding: {
                type: 'pkcs8',
                format: 'pem'
            }
        };
    }

    // Generate RSA key pair
    generateRSAKeyPair() {
        return crypto.generateKeyPairSync('rsa', this.rsaKeyOptions);
    }

    // Generate ECC key pair
    generateECCKeyPair() {
        return crypto.generateKeyPairSync('ec', this.eccKeyOptions);
    }

    // RSA Encryption
    rsaEncrypt(plaintext, publicKey) {
        try {
            const buffer = Buffer.from(plaintext, 'utf8');
            const encrypted = crypto.publicEncrypt({
                key: publicKey,
                padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
                oaepHash: 'sha256'
            }, buffer);
            return encrypted.toString('base64');
        } catch (error) {
            throw new Error(`RSA encryption failed: ${error.message}`);
        }
    }

    // RSA Decryption
    rsaDecrypt(encryptedData, privateKey) {
        try {
            const buffer = Buffer.from(encryptedData, 'base64');
            const decrypted = crypto.privateDecrypt({
                key: privateKey,
                padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
                oaepHash: 'sha256'
            }, buffer);
            return decrypted.toString('utf8');
        } catch (error) {
            throw new Error(`RSA decryption failed: ${error.message}`);
        }
    }

    // Digital Signature with ECC
    signMessage(message, privateKey) {
        try {
            const sign = crypto.createSign('SHA256');
            sign.update(message);
            sign.end();
            const signature = sign.sign(privateKey, 'base64');
            return signature;
        } catch (error) {
            throw new Error(`Signing failed: ${error.message}`);
        }
    }

    // Verify Digital Signature
    verifySignature(message, signature, publicKey) {
        try {
            const verify = crypto.createVerify('SHA256');
            verify.update(message);
            verify.end();
            return verify.verify(publicKey, signature, 'base64');
        } catch (error) {
            throw new Error(`Verification failed: ${error.message}`);
        }
    }

    // ECDH Key Exchange (Elliptic Curve Diffie-Hellman)
    performKeyExchange(privateKeyA, publicKeyB) {
        try {
            const ecdh = crypto.createECDH('secp256k1');
            ecdh.setPrivateKey(crypto.createPrivateKey(privateKeyA).export({
                type: 'sec1',
                format: 'der'
            }));
            
            const publicKeyBBuffer = crypto.createPublicKey(publicKeyB).export({
                type: 'spki',
                format: 'der'
            });
            
            const sharedSecret = ecdh.computeSecret(publicKeyBBuffer);
            return sharedSecret.toString('hex');
        } catch (error) {
            throw new Error(`Key exchange failed: ${error.message}`);
        }
    }
}

// Demonstration
const asymmetricCrypto = new AsymmetricCrypto();

// Generate key pairs
console.log('Generating RSA key pair...');
const rsaKeys = asymmetricCrypto.generateRSAKeyPair();

console.log('Generating ECC key pair...');
const eccKeys = asymmetricCrypto.generateECCKeyPair();

// RSA Encryption/Decryption Demo
const message = "Web3 Odyssey: Mastering Cryptography!";
console.log('Original message:', message);

const encrypted = asymmetricCrypto.rsaEncrypt(message, rsaKeys.publicKey);
console.log('RSA Encrypted:', encrypted);

const decrypted = asymmetricCrypto.rsaDecrypt(encrypted, rsaKeys.privateKey);
console.log('RSA Decrypted:', decrypted);

// Digital Signature Demo
const signature = asymmetricCrypto.signMessage(message, eccKeys.privateKey);
console.log('Digital Signature:', signature);

const isValid = asymmetricCrypto.verifySignature(message, signature, eccKeys.publicKey);
console.log('Signature Valid:', isValid);

// Demonstrate signature verification failure with wrong message
const tamperedMessage = "Web3 Odyssey: Mastering Cryptography! [TAMPERED]";
const isTamperedValid = asymmetricCrypto.verifySignature(tamperedMessage, signature, eccKeys.publicKey);
console.log('Tampered Message Signature Valid:', isTamperedValid);</code></pre>
                </div>

                <p>This implementation demonstrates the versatility of asymmetric cryptography. Notice how we use RSA for encryption (with OAEP padding for security) and ECC for digital signatures. The secp256k1 curve is particularly significant in Web3 as it's the same curve used by Bitcoin and Ethereum for generating addresses and signing transactions.</p>

                <p>The digital signature functionality is crucial for Web3 applications. Every transaction on Ethereum is signed with the sender's private key, allowing the network to verify the transaction's authenticity without revealing the private key. This enables trustless interactions in decentralized systems.</p>
            </div>
        </section>

         Slide 7: Asymmetric Pros & Cons Table 
        <section class="slide">
            <h2>🎯 Asymmetric Encryption: Strengths & Challenges</h2>
            <img src="img7.png" alt="Asymmetric Encryption Analysis" class="slide-image">
            
            <div class="slide-content">
                <p>Asymmetric encryption solves many problems that symmetric encryption cannot address, but it comes with its own set of trade-offs. Understanding these characteristics is essential for designing secure and efficient Web3 systems.</p>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Advantages</th>
                            <th>Limitations</th>
                            <th>Web3 Applications</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>No Key Distribution Problem:</strong> Public keys can be shared openly</td>
                            <td><strong>Computational Overhead:</strong> 100-1000x slower than symmetric encryption</td>
                            <td>Enables trustless peer-to-peer transactions without intermediaries</td>
                        </tr>
                        <tr>
                            <td><strong>Digital Signatures:</strong> Provides authentication and non-repudiation</td>
                            <td><strong>Key Size Requirements:</strong> Larger keys needed for equivalent security</td>
                            <td>Essential for transaction signing and smart contract authentication</td>
                        </tr>
                        <tr>
                            <td><strong>Scalable Security:</strong> N parties need only N key pairs</td>
                            <td><strong>Quantum Vulnerability:</strong> Shor's algorithm threatens RSA and ECC</td>
                            <td>Supports massive decentralized networks with millions of participants</td>
                        </tr>
                        <tr>
                            <td><strong>Key Exchange:</strong> Enables secure communication over insecure channels</td>
                            <td><strong>Implementation Complexity:</strong> More complex algorithms and protocols</td>
                            <td>Facilitates secure communication in decentralized messaging systems</td>
                        </tr>
                        <tr>
                            <td><strong>Forward Secrecy:</strong> Compromise of long-term keys doesn't affect past sessions</td>
                            <td><strong>Certificate Management:</strong> Requires PKI for key authenticity</td>
                            <td>Enables secure key rotation in long-lived smart contracts</td>
                        </tr>
                    </tbody>
                </table>

                <p>The quantum threat is particularly relevant for Web3 systems. While current quantum computers cannot break RSA or ECC, future quantum computers running Shor's algorithm could potentially compromise these systems. This has led to research into post-quantum cryptography, with algorithms like lattice-based cryptography being considered for future blockchain implementations.</p>

                <div class="highlight-box">
                    <strong>Web3-Specific Considerations:</strong><br>
                    • Gas costs on Ethereum make complex cryptographic operations expensive<br>
                    • Deterministic key generation enables HD (Hierarchical Deterministic) wallets<br>
                    • Multi-signature schemes require multiple private keys for transaction approval<br>
                    • Zero-knowledge proofs combine with asymmetric crypto for privacy<br>
                    • Cross-chain bridges rely on asymmetric crypto for asset transfers
                </div>

                <p>In practice, most Web3 applications use hybrid approaches, combining the efficiency of symmetric encryption with the key management advantages of asymmetric encryption. This hybrid model is fundamental to protocols like TLS/SSL, which secure most internet communications today.</p>
            </div>
        </section>

         Slide 8: Web3 Use Cases 
        <section class="slide">
            <h2>🌐 Cryptography in Web3: Real-World Applications</h2>
            <img src="img8.png" alt="Web3 Cryptography Use Cases" class="slide-image">
            
            <div class="slide-content">
                <p>Web3 applications leverage both symmetric and asymmetric cryptography in sophisticated ways to create trustless, decentralized systems. Understanding these applications is crucial for building secure and efficient decentralized applications.</p>

                <h3 style="color: var(--accent-cyan); margin: 25px 0 15px 0;">🔐 Cryptocurrency Wallets</h3>
                <p>Cryptocurrency wallets are perhaps the most visible application of asymmetric cryptography in Web3. Each wallet contains a private key that mathematically corresponds to a public address. When you send cryptocurrency, you're creating a digital signature with your private key that proves ownership of the funds without revealing the key itself.</p>

                <div class="code-block">
                    <pre><code>// Ethereum address generation from private key
const crypto = require('crypto');
const { keccak256 } = require('js-sha3');

function generateEthereumAddress(privateKey) {
    // Generate public key from private key using secp256k1
    const publicKey = crypto.createPublicKey({
        key: privateKey,
        format: 'der',
        type: 'sec1'
    });
    
    // Get uncompressed public key (remove 0x04 prefix)
    const publicKeyBytes = publicKey.export({ type: 'spki', format: 'der' });
    const uncompressedKey = publicKeyBytes.slice(-64);
    
    // Keccak256 hash of public key
    const hash = keccak256(uncompressedKey);
    
    // Take last 20 bytes as Ethereum address
    const address = '0x' + hash.slice(-40);
    return address;
}</code></pre>
                </div>

                <h3 style="color: var(--accent-cyan); margin: 25px 0 15px 0;">📜 Smart Contract Security</h3>
                <p>Smart contracts use cryptographic signatures to verify that function calls are authorized. Multi-signature contracts require multiple private keys to approve transactions, implementing sophisticated access control mechanisms. Time-locked contracts use cryptographic commitments to ensure actions can only be taken after specific conditions are met.</p>

                <h3 style="color: var(--accent-cyan); margin: 25px 0 15px 0;">🔗 Blockchain Consensus</h3>
                <p>Proof-of-Stake consensus mechanisms rely heavily on cryptographic signatures. Validators sign blocks and attestations, and the network uses these signatures to determine consensus. The cryptographic properties ensure that malicious actors cannot forge signatures or double-spend without being detected and penalized.</p>

                <h3 style="color: var(--accent-cyan); margin: 25px 0 15px 0;">🕵️ Privacy-Preserving Technologies</h3>
                <p>Zero-knowledge proofs combine with traditional cryptography to enable privacy-preserving transactions. zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge) allow users to prove they know certain information without revealing the information itself. This enables private transactions on public blockchains.</p>

                <div class="highlight-box">
                    <strong>Hybrid Cryptography in Practice:</strong><br>
                    • HTTPS connections to Web3 dApps use RSA/ECC for key exchange, AES for data encryption<br>
                    • IPFS uses content-addressed storage with cryptographic hashes for integrity<br>
                    • Layer 2 solutions use symmetric encryption for off-chain data, asymmetric for settlement<br>
                    • Decentralized identity systems combine both approaches for comprehensive security<br>
                    • Cross-chain bridges use threshold cryptography for secure asset transfers
                </div>

                <h3 style="color: var(--accent-cyan); margin: 25px 0 15px 0;">🌉 Cross-Chain Interoperability</h3>
                <p>Cross-chain bridges and interoperability protocols use sophisticated cryptographic schemes to enable asset transfers between different blockchains. These systems often employ threshold signatures, where multiple parties must cooperate to create a valid signature, ensuring no single party can control cross-chain assets.</p>
            </div>

            <div class="quiz-section">
                <div class="quiz-title">🧠 Application Challenge</div>
                <div class="quiz-question">In a multi-signature wallet requiring 3 out of 5 signatures, what type of cryptography is primarily used?</div>
                <ul class="quiz-options">
                    <li>A) Symmetric encryption only</li>
                    <li>B) Asymmetric cryptography with threshold signatures</li>
                    <li>C) Hash functions only</li>
                    <li>D) Quantum cryptography</li>
                </ul>
            </div>
        </section>

         Slide 9: Hands-On Exercise + Quiz 
        <section class="slide">
            <h2>🛠️ Hands-On Challenge: Build a Secure Message System</h2>
            <img src="img9.png" alt="Hands-On Exercise" class="slide-image">
            
            <div class="slide-content">
                <p>Now it's time to apply your knowledge! Your challenge is to build a secure messaging system that combines both symmetric and asymmetric cryptography. This exercise will reinforce the concepts we've learned and demonstrate how they work together in real applications.</p>

                <h3 style="color: var(--accent-violet); margin: 25px 0 15px 0;">📋 Exercise Requirements</h3>
                <p>Create a Node.js application that implements a hybrid cryptographic system for secure messaging. Your system should use asymmetric cryptography for key exchange and digital signatures, while using symmetric cryptography for message encryption.</p>

                <div class="code-block">
                    <pre><code>// Your challenge: Complete this secure messaging system
class SecureMessenger {
    constructor() {
        // TODO: Initialize cryptographic components
        this.asymmetricCrypto = new AsymmetricCrypto();
        this.symmetricCrypto = new SymmetricCrypto();
        this.keyPairs = new Map(); // Store user key pairs
        this.sessionKeys = new Map(); // Store session keys
    }

    // TODO: Implement user registration
    registerUser(userId) {
        // Generate key pair for user
        // Store in keyPairs map
        // Return public key for sharing
    }

    // TODO: Implement secure session establishment
    establishSession(userA, userB) {
        // Generate session key using symmetric crypto
        // Encrypt session key with userB's public key
        // Sign the encrypted session key with userA's private key
        // Return encrypted session key and signature
    }

    // TODO: Implement secure message sending
    sendMessage(fromUser, toUser, message) {
        // Retrieve session key for this conversation
        // Encrypt message with symmetric encryption
        // Sign encrypted message with sender's private key
        // Return encrypted message and signature
    }

    // TODO: Implement secure message receiving
    receiveMessage(fromUser, toUser, encryptedMessage, signature) {
        // Verify signature using sender's public key
        // Decrypt message using session key
        // Return decrypted message or throw error if verification fails
    }

    // TODO: Implement key rotation
    rotateSessionKey(userA, userB) {
        // Generate new session key
        // Securely exchange new key
        // Update session keys map
    }
}

// Test your implementation
const messenger = new SecureMessenger();

// Register users
const alicePublicKey = messenger.registerUser('alice');
const bobPublicKey = messenger.registerUser('bob');

// Establish secure session
const sessionData = messenger.establishSession('alice', 'bob');

// Send secure message
const messageData = messenger.sendMessage('alice', 'bob', 'Hello Web3 World!');

// Receive and verify message
const decryptedMessage = messenger.receiveMessage('alice', 'bob', 
    messageData.encrypted, messageData.signature);</code></pre>
                </div>

                <div class="quiz-section">
                    <div class="quiz-title">🧠 Comprehensive Quiz</div>
                    
                    <div class="quiz-question">1. Why do we use hybrid cryptography (combining symmetric and asymmetric) in secure messaging?</div>
                    <ul class="quiz-options">
                        <li>A) To make the system more complex</li>
                        <li>B) To leverage the speed of symmetric encryption and the key management benefits of asymmetric encryption</li>
                        <li>C) To increase the message size</li>
                        <li>D) To reduce security</li>
                    </ul>

                    <div class="quiz-question">2. In the context of Web3, what is the primary purpose of digital signatures?</div>
                    <ul class="quiz-options">
                        <li>A) To encrypt transaction data</li>
                        <li>B) To prove ownership and authorize transactions without revealing private keys</li>
                        <li>C) To compress transaction data</li>
                        <li>D) To speed up transaction processing</li>
                    </ul>

                    <div class="quiz-question">3. What happens if a symmetric encryption key is compromised?</div>
                    <ul class="quiz-options">
                        <li>A) Only future messages are at risk</li>
                        <li>B) All past and future messages encrypted with that key are compromised</li>
                        <li>C) The system automatically generates a new key</li>
                        <li>D) Nothing, the system remains secure</li>
                    </ul>

                    <div class="quiz-question">4. Which cryptographic primitive is essential for creating cryptocurrency addresses?</div>
                    <ul class="quiz-options">
                        <li>A) Symmetric encryption</li>
                        <li>B) Hash functions and asymmetric key generation</li>
                        <li>C) Random number generation only</li>
                        <li>D) Compression algorithms</li>
                    </ul>
                </div>

                <div class="highlight-box">
                    <strong>Exercise Extensions:</strong><br>
                    • Add perfect forward secrecy by implementing ephemeral key exchange<br>
                    • Implement message integrity verification using HMAC<br>
                    • Add support for group messaging with shared session keys<br>
                    • Implement key escrow for message recovery<br>
                    • Add rate limiting and anti-spam measures using proof-of-work
                </div>
            </div>
        </section>

         Slide 10: Summary & Further Reading 
        <section class="slide">
            <h2>🎓 Summary & Your Cryptographic Journey Ahead</h2>
            <img src="img10.png" alt="Summary and Next Steps" class="slide-image">
            
            <div class="slide-content">
                <p>Congratulations! You've completed a comprehensive exploration of symmetric and asymmetric cryptography in the context of Web3 development. Let's consolidate your learning and chart the path forward in your cryptographic mastery journey.</p>

                <h3 style="color: var(--accent-cyan); margin: 25px 0 15px 0;">🔑 Key Takeaways</h3>
                <p><strong>Symmetric Cryptography:</strong> Fast, efficient, perfect for bulk data encryption, but faces key distribution challenges. Essential for encrypting large amounts of data in Web3 applications, from blockchain state to off-chain storage.</p>

                <p><strong>Asymmetric Cryptography:</strong> Solves key distribution, enables digital signatures and authentication, but computationally expensive. Forms the foundation of Web3 identity, transaction authorization, and trustless interactions.</p>

                <p><strong>Hybrid Systems:</strong> Combine the best of both worlds, using asymmetric cryptography for key exchange and digital signatures, while leveraging symmetric cryptography for efficient data encryption. This approach powers most modern secure communication protocols.</p>

                <h3 style="color: var(--accent-violet); margin: 25px 0 15px 0;">🚀 Advanced Topics to Explore</h3>
                <div class="highlight-box">
                    <strong>Next Learning Modules:</strong><br>
                    • <strong>Hash Functions & Merkle Trees:</strong> The building blocks of blockchain integrity<br>
                    • <strong>Digital Signatures & Multi-Sig:</strong> Advanced authentication mechanisms<br>
                    • <strong>Zero-Knowledge Proofs:</strong> Privacy-preserving cryptographic protocols<br>
                    • <strong>Post-Quantum Cryptography:</strong> Preparing for the quantum computing era<br>
                    • <strong>Threshold Cryptography:</strong> Distributed trust and secret sharing
                </div>

                <h3 style="color: var(--accent-cyan); margin: 25px 0 15px 0;">📚 Recommended Resources</h3>
                <p><strong>Books:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 20px;">
                    <li>"Applied Cryptography" by Bruce Schneier - Comprehensive cryptographic reference</li>
                    <li>"Mastering Bitcoin" by Andreas Antonopoulos - Cryptography in cryptocurrency context</li>
                    <li>"Serious Cryptography" by Jean-Philippe Aumasson - Modern cryptographic practices</li>
                </ul>

                <p><strong>Online Resources:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 20px;">
                    <li>Cryptopals Challenges - Hands-on cryptographic problem solving</li>
                    <li>NIST Cryptographic Standards - Official cryptographic guidelines</li>
                    <li>Ethereum Yellow Paper - Technical specification of Ethereum cryptography</li>
                </ul>

                <h3 style="color: var(--accent-violet); margin: 25px 0 15px 0;">🛠️ Practical Next Steps</h3>
                <p>1. <strong>Complete the hands-on exercise</strong> from Slide 9 to reinforce your understanding</p>
                <p>2. <strong>Experiment with different algorithms</strong> - try implementing ChaCha20, Ed25519, or other modern cryptographic primitives</p>
                <p>3. <strong>Build a simple blockchain</strong> using the cryptographic concepts you've learned</p>
                <p>4. <strong>Explore Web3 libraries</strong> like ethers.js or web3.js to see cryptography in action</p>
                <p>5. <strong>Study real-world implementations</strong> in popular cryptocurrency wallets and dApps</p>

                <div class="quiz-section">
                    <div class="quiz-title">🧠 Final Assessment</div>
                    <div class="quiz-question">What is the most important principle when implementing cryptographic systems in production?</div>
                    <ul class="quiz-options">
                        <li>A) Use the fastest algorithm available</li>
                        <li>B) Never implement cryptography yourself - use well-tested, peer-reviewed libraries</li>
                        <li>C) Always use the most complex algorithm</li>
                        <li>D) Prioritize code readability over security</li>
                    </ul>
                </div>

                <div class="highlight-box">
                    <strong>Remember:</strong> Cryptography is both an art and a science. While understanding the theory is crucial, practical implementation requires careful attention to security details, proper key management, and staying updated with the latest security research. Never implement cryptographic primitives from scratch in production systems - always use well-tested, peer-reviewed libraries.
                </div>

                <p style="text-align: center; font-size: 1.2rem; color: var(--accent-cyan); margin-top: 30px;">
                    <strong>Welcome to the future of decentralized technology! 🌟</strong>
                </p>
            </div>
        </section>

    </main>

     Footer 
    <footer class="footer">
        <p>© 2025 MOKSHA STUDIOS — Building the Future of Web3 Education</p>
        <p style="margin-top: 10px; font-size: 0.8rem; color: var(--text-muted);">
            Part of the MOKSHA Innovators Guild Educational Initiative
        </p>
    </footer>

</body>
</html>

// Method 1: Using random key
const randomKey = aes.generateKey();
const sensitiveData = "User private key: 0x1a2b3c4d5e6
