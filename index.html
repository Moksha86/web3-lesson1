f7890abcdef";
const encrypted = aes.encrypt(sensitiveData, randomKey);
console.log("Encrypted:", encrypted);
const decrypted = aes.decrypt(encrypted, randomKey);
console.log("Decrypted:", decrypted);

// Method 2: Using password-derived key
const password = "MySecurePassword123!";
const salt = crypto.randomBytes(32); // Always use random salt
const derivedKey = aes.deriveKeyFromPassword(password, salt);
const encryptedWithPassword = aes.encrypt(sensitiveData, derivedKey);
console.log("Password-encrypted:", encryptedWithPassword);

// Demonstrate secure key storage (conceptual)
class SecureKeyManager {
    constructor() {
        this.keys = new Map();
        this.keyMetadata = new Map();
    }

    storeKey(keyId, key, metadata = {}) {
        // In production, keys would be stored in secure hardware or key management service
        this.keys.set(keyId, key);
        this.keyMetadata.set(keyId, {
            ...metadata,
            createdAt: new Date(),
            accessCount: 0
        });
    }

    retrieveKey(keyId) {
        const key = this.keys.get(keyId);
        if (key) {
            const metadata = this.keyMetadata.get(keyId);
            metadata.accessCount++;
            metadata.lastAccessed = new Date();
            return key;
        }
        throw new Error('Key not found');
    }

    rotateKey(keyId) {
        // Key rotation for enhanced security
        const oldKey = this.keys.get(keyId);
        if (oldKey) {
            const newKey = aes.generateKey();
            this.storeKey(keyId, newKey, { rotatedFrom: oldKey.toString('hex').substring(0, 8) });
            return newKey;
        }
        throw new Error('Key not found for rotation');
    }
}
</code></pre>

            <h4>Triple DES (3DES)</h4>
            
            <p>Triple DES, or 3DES, was developed as an interim solution to address the security vulnerabilities of the original DES. By applying DES encryption three times with different keys, 3DES effectively increases the key space and provides enhanced security. However, its slower performance compared to AES has led to its gradual phase-out in favor of more modern algorithms.</p>

            <pre><code>// 3DES Implementation Example
const crypto = require('crypto');

class TripleDESEncryption {
    constructor() {
        this.algorithm = 'des-ede3-cbc'; // Triple DES with CBC mode
        this.keyLength = 24; // 192 bits (3 * 64-bit DES keys)
        this.ivLength = 8;   // 64 bits
    }

    encrypt(plaintext, key) {
        const iv = crypto.randomBytes(this.ivLength);
        const cipher = crypto.createCipher(this.algorithm, key, iv);
        
        let encrypted = cipher.update(plaintext, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        return iv.toString('hex') + ':' + encrypted;
    }

    decrypt(encryptedData, key) {
        const parts = encryptedData.split(':');
        const iv = Buffer.from(parts[0], 'hex');
        const encrypted = parts[1];
        
        const decipher = crypto.createDecipher(this.algorithm, key, iv);
        
        let decrypted = decipher.update(encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }
}

// Performance comparison helper
function benchmarkEncryption(algorithm, data, iterations = 1000) {
    const startTime = process.hrtime();
    
    for (let i = 0; i < iterations; i++) {
        algorithm.encrypt(data, algorithm.generateKey());
    }
    
    const endTime = process.hrtime(startTime);
    const totalTime = endTime[0] * 1000 + endTime[1] / 1000000; // Convert to milliseconds
    
    return {
        totalTime,
        averageTime: totalTime / iterations,
        operationsPerSecond: iterations / (totalTime / 1000)
    };
}
</code></pre>

            <h4>ChaCha20</h4>
            
            <p>ChaCha20, developed by Daniel J. Bernstein, represents a newer approach to stream cipher design. It offers excellent security properties and performance, particularly on mobile and embedded devices where AES hardware acceleration may not be available. ChaCha20 is increasingly adopted in modern protocols, including TLS 1.3 and the Signal messaging protocol.</p>

            <div class="highlight-box">
                <h5>ChaCha20 Advantages</h5>
                <ul>
                    <li><strong>Software Performance:</strong> Excellent performance on platforms without AES hardware acceleration</li>
                    <li><strong>Constant-Time Operation:</strong> Designed to resist timing attacks</li>
                    <li><strong>Simplicity:</strong> Relatively simple implementation reduces the risk of bugs</li>
                    <li><strong>Cryptographic Security:</strong> Strong resistance to known attacks</li>
                </ul>
            </div>

            <img src="img4.png" alt="Symmetric Cryptography Performance Analysis and Comparison Matrix" class="lesson-image diagram-image">

            <h3>Performance Characteristics and Benchmarking</h3>
            
            <p>Understanding the performance characteristics of different symmetric algorithms is crucial for making informed decisions in system design. The following analysis provides comprehensive benchmarking data and performance considerations.</p>

            <div class="performance-chart">
                <h4>Algorithm Performance Comparison</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Algorithm</th>
                            <th>Key Size (bits)</th>
                            <th>Block Size (bits)</th>
                            <th>Throughput (MB/s)*</th>
                            <th>Memory Usage</th>
                            <th>Hardware Support</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>AES-128</td>
                            <td>128</td>
                            <td>128</td>
                            <td>1,200-4,000</td>
                            <td>Low</td>
                            <td>Extensive</td>
                        </tr>
                        <tr>
                            <td>AES-256</td>
                            <td>256</td>
                            <td>128</td>
                            <td>800-3,200</td>
                            <td>Low</td>
                            <td>Extensive</td>
                        </tr>
                        <tr>
                            <td>3DES</td>
                            <td>192</td>
                            <td>64</td>
                            <td>45-100</td>
                            <td>Medium</td>
                            <td>Legacy</td>
                        </tr>
                        <tr>
                            <td>ChaCha20</td>
                            <td>256</td>
                            <td>N/A (Stream)</td>
                            <td>600-1,500</td>
                            <td>Low</td>
                            <td>Limited</td>
                        </tr>
                    </tbody>
                </table>
                <p style="font-size: 0.9em; color: #7fc1ff;">*Performance varies significantly based on hardware, implementation, and whether hardware acceleration is available</p>
            </div>

            <h3>Security Considerations and Best Practices</h3>
            
            <h4>Key Management</h4>
            
            <p>Proper key management represents perhaps the most critical aspect of symmetric cryptography implementation. Even the strongest algorithm becomes vulnerable if keys are poorly managed.</p>

            <div class="warning-box">
                <h5>Critical Key Management Principles</h5>
                <ul>
                    <li><strong>Key Generation:</strong> Always use cryptographically secure random number generators</li>
                    <li><strong>Key Storage:</strong> Never store keys in plain text; use secure key management systems</li>
                    <li><strong>Key Distribution:</strong> Employ secure channels for key distribution (out-of-band methods preferred)</li>
                    <li><strong>Key Rotation:</strong> Regularly rotate keys to limit exposure from potential compromises</li>
                    <li><strong>Key Destruction:</strong> Securely destroy keys when they're no longer needed</li>
                </ul>
            </div>

            <pre><code>// Advanced Key Management Implementation
class EnterpriseKeyManager {
    constructor() {
        this.keyStore = new Map();
        this.keyPolicies = new Map();
        this.auditLog = [];
    }

    // Generate key with policy enforcement
    generateKey(keyId, policy = {}) {
        const defaultPolicy = {
            algorithm: 'aes-256-gcm',
            maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
            maxOperations: 1000000,
            rotationThreshold: 0.8
        };

        const keyPolicy = { ...defaultPolicy, ...policy };
        
        // Generate cryptographically secure key
        const key = crypto.randomBytes(32); // 256-bit key
        
        const keyMetadata = {
            id: keyId,
            key: key,
            policy: keyPolicy,
            createdAt: new Date(),
            operationCount: 0,
            lastUsed: new Date(),
            status: 'active'
        };

        this.keyStore.set(keyId, keyMetadata);
        this.keyPolicies.set(keyId, keyPolicy);
        
        this.auditLog.push({
            action: 'KEY_GENERATED',
            keyId: keyId,
            timestamp: new Date(),
            metadata: { algorithm: keyPolicy.algorithm }
        });

        return keyId;
    }

    // Retrieve key with policy checks
    getKey(keyId, operation = 'encrypt') {
        const keyData = this.keyStore.get(keyId);
        
        if (!keyData) {
            throw new Error(`Key ${keyId} not found`);
        }

        // Check key status
        if (keyData.status !== 'active') {
            throw new Error(`Key ${keyId} is not active`);
        }

        // Check age policy
        const age = Date.now() - keyData.createdAt.getTime();
        if (age > keyData.policy.maxAge) {
            throw new Error(`Key ${keyId} has exceeded maximum age`);
        }

        // Check operation count policy
        if (keyData.operationCount >= keyData.policy.maxOperations) {
            throw new Error(`Key ${keyId} has exceeded maximum operations`);
        }

        // Update usage statistics
        keyData.operationCount++;
        keyData.lastUsed = new Date();

        // Check if rotation is needed
        const operationRatio = keyData.operationCount / keyData.policy.maxOperations;
        const ageRatio = age / keyData.policy.maxAge;
        
        if (operationRatio >= keyData.policy.rotationThreshold || 
            ageRatio >= keyData.policy.rotationThreshold) {
            this.scheduleKeyRotation(keyId);
        }

        this.auditLog.push({
            action: 'KEY_ACCESSED',
            keyId: keyId,
            operation: operation,
            timestamp: new Date()
        });

        return keyData.key;
    }

    // Automated key rotation
    scheduleKeyRotation(keyId) {
        const keyData = this.keyStore.get(keyId);
        if (!keyData) return;

        // Generate new key with same policy
        const newKeyId = keyId + '_v' + Date.now();
        this.generateKey(newKeyId, keyData.policy);

        // Mark old key for deprecation
        keyData.status = 'deprecated';
        
        this.auditLog.push({
            action: 'KEY_ROTATION_SCHEDULED',
            oldKeyId: keyId,
            newKeyId: newKeyId,
            timestamp: new Date()
        });

        return newKeyId;
    }

    // Secure key destruction
    destroyKey(keyId) {
        const keyData = this.keyStore.get(keyId);
        if (keyData) {
            // Overwrite key data with random bytes (defense against memory dumps)
            keyData.key.fill(0);
            crypto.randomFillSync(keyData.key);
            
            keyData.status = 'destroyed';
            
            this.auditLog.push({
                action: 'KEY_DESTROYED',
                keyId: keyId,
                timestamp: new Date()
            });
        }
    }

    // Generate audit report
    generateAuditReport(startDate, endDate) {
        return this.auditLog.filter(entry => 
            entry.timestamp >= startDate && entry.timestamp <= endDate
        ).map(entry => ({
            ...entry,
            timestamp: entry.timestamp.toISOString()
        }));
    }
}
</code></pre>

            <h4>Mode of Operation Considerations</h4>
            
            <p>The mode of operation determines how a block cipher processes data larger than a single block. The choice of mode significantly impacts both security and performance characteristics.</p>

            <table>
                <thead>
                    <tr>
                        <th>Mode</th>
                        <th>Security Level</th>
                        <th>Parallelizable</th>
                        <th>Padding Required</th>
                        <th>Best Use Cases</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>ECB</td>
                        <td>Low (Not Recommended)</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>None (Deprecated)</td>
                    </tr>
                    <tr>
                        <td>CBC</td>
                        <td>Medium-High</td>
                        <td>Decrypt Only</td>
                        <td>Yes</td>
                        <td>File Encryption</td>
                    </tr>
                    <tr>
                        <td>GCM</td>
                        <td>Very High</td>
                        <td>Yes</td>
                        <td>No</td>
                        <td>Network Communications</td>
                    </tr>
                    <tr>
                        <td>CTR</td>
                        <td>High</td>
                        <td>Yes</td>
                        <td>No</td>
                        <td>Real-time Streaming</td>
                    </tr>
                </tbody>
            </table>

            <h3>Hands-On Implementation Exercise</h3>
            
            <p>Let's implement a comprehensive file encryption system that demonstrates best practices in symmetric cryptography:</p>

            <pre><code>// Professional File Encryption System
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');

class SecureFileEncryption {
    constructor() {
        this.algorithm = 'aes-256-gcm';
        this.keyLength = 32; // 256 bits
        this.ivLength = 12;  // 96 bits for GCM
        this.tagLength = 16; // 128 bits authentication tag
        this.saltLength = 32; // 256 bits for key derivation
        this.iterations = 100000; // PBKDF2 iterations
    }

    // Derive key from password using PBKDF2
    async deriveKey(password, salt) {
        return new Promise((resolve, reject) => {
            crypto.pbkdf2(password, salt, this.iterations, this.keyLength, 'sha256', (err, key) => {
                if (err) reject(err);
                else resolve(key);
            });
        });
    }

    // Encrypt file with authenticated encryption
    async encryptFile(inputPath, outputPath, password) {
        try {
            // Read input file
            const plaintext = await fs.readFile(inputPath);
            
            // Generate random salt and IV
            const salt = crypto.randomBytes(this.saltLength);
            const iv = crypto.randomBytes(this.ivLength);
            
            // Derive key from password
            const key = await this.deriveKey(password, salt);
            
            // Create cipher
            const cipher = crypto.createCipher(this.algorithm, key, { iv });
            
            // Encrypt data
            const encrypted = Buffer.concat([
                cipher.update(plaintext),
                cipher.final()
            ]);
            
            // Get authentication tag
            const tag = cipher.getAuthTag();
            
            // Create file header with metadata
            const header = Buffer.alloc(4 + 4 + 4); // version + salt_len + iv_len
            header.writeUInt32BE(1, 0); // Version
            header.writeUInt32BE(this.saltLength, 4);
            header.writeUInt32BE(this.ivLength, 8);
            
            // Combine all components
            const output = Buffer.concat([
                header,
                salt,
                iv,
                tag,
                encrypted
            ]);
            
            // Write encrypted file
            await fs.writeFile(outputPath, output);
            
            return {
                success: true,
                originalSize: plaintext.length,
                encryptedSize: output.length,
                overhead: output.length - plaintext.length
            };
            
        } catch (error) {
            throw new Error(`Encryption failed: ${error.message}`);
        }
    }

    // Decrypt file with authentication verification
    async decryptFile(inputPath, outputPath, password) {
        try {
            // Read encrypted file
            const encrypted = await fs.readFile(inputPath);
            
            let offset = 0;
            
            // Parse header
            const version = encrypted.readUInt32BE(offset);
            offset += 4;
            
            if (version !== 1) {
                throw new Error('Unsupported file version');
            }
            
            const saltLength = encrypted.readUInt32BE(offset);
            offset += 4;
            const ivLength = encrypted.readUInt32BE(offset);
            offset += 4;
            
            // Extract components
            const salt = encrypted.slice(offset, offset + saltLength);
            offset += saltLength;
            
            const iv = encrypted.slice(offset, offset + ivLength);
            offset += ivLength;
            
            const tag = encrypted.slice(offset, offset + this.tagLength);
            offset += this.tagLength;
            
            const ciphertext = encrypted.slice(offset);
            
            // Derive key from password
            const key = await this.deriveKey(password, salt);
            
            // Create decipher
            const decipher = crypto.createDecipher(this.algorithm, key, { iv });
            decipher.setAuthTag(tag);
            
            // Decrypt data
            const plaintext = Buffer.concat([
                decipher.update(ciphertext),
                decipher.final()
            ]);
            
            // Write decrypted file
            await fs.writeFile(outputPath, plaintext);
            
            return {
                success: true,
                decryptedSize: plaintext.length
            };
            
        } catch (error) {
            throw new Error(`Decryption failed: ${error.message}`);
        }
    }

    // Secure file shredding (multiple overwrites)
    async secureDelete(filePath) {
        try {
            const stats = await fs.stat(filePath);
            const fileSize = stats.size;
            
            // Multiple overwrite passes
            const patterns = [
                Buffer.alloc(fileSize, 0x00), // Zeros
                Buffer.alloc(fileSize, 0xFF), // Ones
                crypto.randomBytes(fileSize)   // Random
            ];
            
            for (const pattern of patterns) {
                await fs.writeFile(filePath, pattern);
                await fs.fsync(filePath); // Force write to disk
            }
            
            // Finally delete the file
            await fs.unlink(filePath);
            
            return { success: true, message: 'File securely deleted' };
            
        } catch (error) {
            throw new Error(`Secure deletion failed: ${error.message}`);
        }
    }
}

// Usage demonstration
async function demonstrateFileEncryption() {
    const encryptor = new SecureFileEncryption();
    const testFile = 'sensitive_document.txt';
    const encryptedFile = 'sensitive_document.enc';
    const decryptedFile = 'sensitive_document_recovered.txt';
    const password = 'MyVerySecurePassword123!';
    
    try {
        // Create test file
        await fs.writeFile(testFile, 'This is sensitive information that needs to be encrypted securely.');
        
        // Encrypt file
        console.log('Encrypting file...');
        const encResult = await encryptor.encryptFile(testFile, encryptedFile, password);
        console.log('Encryption result:', encResult);
        
        // Decrypt file
        console.log('Decrypting file...');
        const decResult = await encryptor.decryptFile(encryptedFile, decryptedFile, password);
        console.log('Decryption result:', decResult);
        
        // Verify content
        const original = await fs.readFile(testFile, 'utf8');
        const recovered = await fs.readFile(decryptedFile, 'utf8');
        
        console.log('Content verification:', original === recovered ? 'PASSED' : 'FAILED');
        
        // Clean up
        await encryptor.secureDelete(testFile);
        await encryptor.secureDelete(decryptedFile);
        
    } catch (error) {
        console.error('Demonstration failed:', error.message);
    }
}

// Run demonstration
demonstrateFileEncryption().catch(console.error);
</code></pre>

            <div class="success-box">
                <h4>Key Takeaways from Symmetric Cryptography</h4>
                <ul>
                    <li><strong>Speed and Efficiency:</strong> Symmetric algorithms are significantly faster than asymmetric algorithms</li>
                    <li><strong>Key Management Challenge:</strong> The primary weakness is secure key distribution and management</li>
                    <li><strong>Perfect for Bulk Data:</strong> Ideal for encrypting large amounts of data efficiently</li>
                    <li><strong>Authentication Integration:</strong> Modern modes like GCM provide both confidentiality and authenticity</li>
                    <li><strong>Hardware Acceleration:</strong> Many platforms provide dedicated hardware support for algorithms like AES</li>
                </ul>
            </div>

            <h3>Symmetric Cryptography in Blockchain Context</h3>
            
            <p>In blockchain and Web3 applications, symmetric cryptography plays several crucial roles:</p>

            <h4>Transaction Data Encryption</h4>
            
            <p>While blockchain transactions are typically public, symmetric encryption is often used for:</p>

            <ul>
                <li><strong>Private Transactions:</strong> Zero-knowledge protocols often use symmetric encryption for data confidentiality</li>
                <li><strong>Off-chain Data Storage:</strong> Sensitive data referenced by smart contracts but stored off-chain</li>
                <li><strong>Communication Channels:</strong> Secure communication between blockchain nodes and clients</li>
            </ul>

            <h4>Layer 2 Privacy Solutions</h4>
            
            <p>Layer 2 scaling solutions frequently employ symmetric cryptography for privacy-preserving features:</p>

            <pre><code>// Example: Encrypted State Channels
class EncryptedStateChannel {
    constructor(participants) {
        this.participants = participants;
        this.channelKey = crypto.randomBytes(32); // Shared symmetric key
        this.state = {};
        this.nonce = 0;
    }

    // Encrypt state update
    encryptStateUpdate(update) {
        const iv = crypto.randomBytes(12);
        const cipher = crypto.createCipher('aes-256-gcm', this.channelKey, { iv });
        
        const data = JSON.stringify({
            update,
            nonce: ++this.nonce,
            timestamp: Date.now()
        });
        
        const encrypted = Buffer.concat([
            cipher.update(data, 'utf8'),
            cipher.final()
        ]);
        
        const tag = cipher.getAuthTag();
        
        return {
            iv: iv.toString('hex'),
            data: encrypted.toString('hex'),
            tag: tag.toString('hex')
        };
    }

    // Decrypt state update
    decryptStateUpdate(encryptedUpdate) {
        const iv = Buffer.from(encryptedUpdate.iv, 'hex');
        const data = Buffer.from(encryptedUpdate.data, 'hex');
        const tag = Buffer.from(encryptedUpdate.tag, 'hex');
        
        const decipher = crypto.createDecipher('aes-256-gcm', this.channelKey, { iv });
        decipher.setAuthTag(tag);
        
        const decrypted = Buffer.concat([
            decipher.update(data),
            decipher.final()
        ]).toString('utf8');
        
        return JSON.parse(decrypted);
    }
}
</code></pre>

        </section>

        <div class="section-divider"></div>

        <!-- Section 3: Asymmetric Cryptography -->
        <section id="asymmetric-cryptography">
            <img src="img5.png" alt<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web3 Odyssey | Module 1: Foundations | Lesson 1.1 Symmetric vs Asymmetric Cryptography</title>
    <link rel="icon" href="favicon.png" type="image/png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            color: #e8e8e8;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 25%, #1e3c72 50%, #2a5298 75%, #1e3c72 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(30, 60, 114, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid #7fc1ff;
            z-index: 1000;
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .header-logo {
            height: 80px;
            width: auto;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.4));
            transition: transform 0.3s ease;
        }

        .header-logo:hover {
            transform: scale(1.05);
        }

        main {
            max-width: 980px;
            margin: 140px auto 0;
            padding: 40px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-family: 'Roboto Slab', serif;
            font-size: 2.5rem;
            color: #7fc1ff;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 0 2px 10px rgba(127, 193, 255, 0.3);
        }

        h2 {
            font-family: 'Roboto Slab', serif;
            font-size: 2rem;
            color: #3b79d6;
            margin: 40px 0 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #7fc1ff;
            position: relative;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100px;
            height: 2px;
            background: linear-gradient(90deg, #7fc1ff, #3b79d6);
        }

        h3 {
            font-family: 'Roboto Slab', serif;
            font-size: 1.5rem;
            color: #7fc1ff;
            margin: 30px 0 15px;
        }

        h4 {
            font-family: 'Roboto Slab', serif;
            font-size: 1.3rem;
            color: #a8d0ff;
            margin: 25px 0 12px;
        }

        h5 {
            font-family: 'Roboto Slab', serif;
            font-size: 1.1rem;
            color: #b8e0ff;
            margin: 20px 0 10px;
        }

        p {
            margin-bottom: 15px;
            color: #e8e8e8;
            text-align: justify;
            font-size: 1rem;
            line-height: 1.7;
        }

        .lesson-image {
            display: block;
            margin: 40px auto;
            max-width: 800px;
            width: 100%;
            height: auto;
            min-height: 400px;
            border-radius: 20px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(127, 193, 255, 0.4);
            transition: all 0.4s ease;
            background: linear-gradient(135deg, rgba(127, 193, 255, 0.1), rgba(59, 121, 214, 0.1));
            object-fit: cover;
        }

        .lesson-image:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.8);
            border-color: rgba(127, 193, 255, 0.8);
        }

        .code-image {
            max-width: 900px;
            min-height: 500px;
        }

        .overview-image {
            max-width: 850px;
            min-height: 450px;
        }

        .diagram-image {
            max-width: 750px;
            min-height: 400px;
        }

        ul, ol {
            margin: 15px 0 15px 30px;
            color: #e8e8e8;
        }

        li {
            margin-bottom: 8px;
            line-height: 1.6;
        }

        ul li::marker {
            color: #7fc1ff;
        }

        ol li::marker {
            color: #7fc1ff;
            font-weight: bold;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid rgba(127, 193, 255, 0.2);
        }

        th {
            background: linear-gradient(135deg, #3b79d6, #7fc1ff);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        tr:hover {
            background: rgba(127, 193, 255, 0.1);
        }

        pre {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #7fc1ff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        code {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #7fc1ff;
            line-height: 1.5;
        }

        blockquote {
            border-left: 4px solid #7fc1ff;
            background: rgba(127, 193, 255, 0.1);
            padding: 20px 30px;
            margin: 25px 0;
            border-radius: 0 10px 10px 0;
            font-style: italic;
            position: relative;
        }

        blockquote::before {
            content: '"';
            font-size: 4rem;
            color: #7fc1ff;
            position: absolute;
            top: -10px;
            left: 10px;
            opacity: 0.3;
        }

        .highlight-box {
            background: linear-gradient(135deg, rgba(127, 193, 255, 0.1), rgba(59, 121, 214, 0.1));
            border: 2px solid #7fc1ff;
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            position: relative;
        }

        .highlight-box::before {
            content: '💡';
            position: absolute;
            top: -15px;
            left: 20px;
            background: #1e3c72;
            padding: 5px 10px;
            border-radius: 50%;
            font-size: 1.2rem;
        }

        .warning-box {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.1), rgba(255, 152, 0, 0.1));
            border: 2px solid #ffc107;
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            position: relative;
        }

        .warning-box::before {
            content: '⚠️';
            position: absolute;
            top: -15px;
            left: 20px;
            background: #1e3c72;
            padding: 5px 10px;
            border-radius: 50%;
            font-size: 1.2rem;
        }

        .success-box {
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(25, 135, 84, 0.1));
            border: 2px solid #28a745;
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            position: relative;
        }

        .success-box::before {
            content: '✅';
            position: absolute;
            top: -15px;
            left: 20px;
            background: #1e3c72;
            padding: 5px 10px;
            border-radius: 50%;
            font-size: 1.2rem;
        }

        .emoji {
            font-size: 1.2em;
            margin-right: 8px;
        }

        .section-divider {
            height: 3px;
            background: linear-gradient(90deg, transparent, #7fc1ff, transparent);
            margin: 50px 0;
            border-radius: 2px;
        }

        footer {
            text-align: center;
            padding: 40px 20px;
            background: rgba(30, 60, 114, 0.8);
            margin-top: 60px;
            border-top: 2px solid #7fc1ff;
            color: #7fc1ff;
            font-weight: 500;
        }

        .quiz-question {
            background: rgba(59, 121, 214, 0.1);
            border: 1px solid #3b79d6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .quiz-options {
            list-style: none;
            margin-left: 0;
        }

        .quiz-options li {
            background: rgba(127, 193, 255, 0.1);
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .quiz-options li:hover {
            background: rgba(127, 193, 255, 0.2);
        }

        .performance-chart {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        @media (max-width: 768px) {
            main {
                margin: 100px 20px 0;
                padding: 20px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            .lesson-image {
                max-width: 100%;
            }
            
            pre {
                font-size: 0.8rem;
                padding: 15px;
            }
            
            header {
                padding: 8px 15px;
            }
            
            .header-logo {
                height: 50px;
            }
            
            .header-text h1 {
                font-size: 1.3rem;
            }
            
            .header-text p {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <img src="logo.png" alt="MOKSHA STUDIOS Logo" class="header-logo">
    </header>

    <main>
        <h1><span class="emoji">🔐</span>Lesson 1.1: Symmetric vs Asymmetric Cryptography</h1>

        <!-- Section 1: Lesson Overview -->
        <section id="lesson-overview">
            <img src="img1.png" alt="Comprehensive Lesson Overview - Web3 Cryptography Fundamentals" class="lesson-image overview-image">
            
            <h2><span class="emoji">🎯</span>Comprehensive Lesson Overview</h2>
            
            <p>Welcome to the first foundational lesson of the Web3 Odyssey course! In this comprehensive exploration, we will dive deep into the cryptographic principles that form the bedrock of blockchain technology and decentralized systems. Cryptography is not merely a theoretical concept—it is the invisible force that secures our digital transactions, protects our privacy, and enables trust in trustless environments.</p>

            <p>The distinction between symmetric and asymmetric cryptography represents one of the most fundamental concepts in modern computer security. Understanding these paradigms is crucial for anyone seeking to build, analyze, or work with Web3 technologies. From securing wallet communications to validating smart contract transactions, these cryptographic methods are woven into every aspect of the decentralized web.</p>

            <h3>What is Cryptography?</h3>
            
            <p>Cryptography, derived from the Greek words "kryptos" (hidden) and "graphein" (to write), is the science of securing information through mathematical algorithms and protocols. In the digital age, cryptography serves multiple critical functions:</p>

            <ul>
                <li><strong>Confidentiality:</strong> Ensuring that sensitive information remains private and inaccessible to unauthorized parties</li>
                <li><strong>Integrity:</strong> Guaranteeing that data has not been altered or tampered with during transmission or storage</li>
                <li><strong>Authentication:</strong> Verifying the identity of parties involved in communication or transactions</li>
                <li><strong>Non-repudiation:</strong> Preventing parties from denying their participation in a transaction or communication</li>
                <li><strong>Authorization:</strong> Controlling access to resources and ensuring only authorized users can perform specific actions</li>
            </ul>

            <p>In the context of Web3 and blockchain technology, these cryptographic principles enable the creation of decentralized systems that operate without centralized authorities while maintaining security and trust.</p>

            <h3>Learning Objectives</h3>
            
            <p>By the end of this lesson, you will have achieved a comprehensive understanding of:</p>

            <ol>
                <li><strong>Symmetric Cryptography Mastery:</strong> Understand the fundamental principles, algorithms, and practical applications of symmetric encryption, including hands-on implementation experience with industry-standard algorithms like AES-256</li>
                <li><strong>Asymmetric Cryptography Expertise:</strong> Grasp the mathematical foundations of public-key cryptography, explore RSA and elliptic curve algorithms, and understand how these systems solve the key distribution problem</li>
                <li><strong>Comparative Analysis Skills:</strong> Develop the ability to evaluate and compare different cryptographic approaches, understanding when and why to use each method in various scenarios</li>
                <li><strong>Blockchain Integration Knowledge:</strong> Learn how both symmetric and asymmetric cryptography are integrated into blockchain protocols, smart contracts, and Web3 applications</li>
                <li><strong>Security Implementation:</strong> Gain practical experience implementing cryptographic solutions and understanding common security pitfalls and best practices</li>
                <li><strong>Performance Optimization:</strong> Understand the performance implications of different cryptographic choices and how to optimize for various use cases</li>
            </ol>

            <h3>Real-World Relevance in Web3</h3>
            
            <p>The concepts we explore in this lesson have immediate and profound relevance to the Web3 ecosystem. Consider these real-world applications:</p>

            <div class="highlight-box">
                <h4>Ethereum Transaction Security</h4>
                <p>Every Ethereum transaction combines both symmetric and asymmetric cryptography. The transaction data may be encrypted using symmetric algorithms for efficiency, while the transaction signature uses elliptic curve digital signatures (asymmetric) to prove ownership and prevent tampering.</p>
            </div>

            <div class="highlight-box">
                <h4>Decentralized Identity (DID)</h4>
                <p>Self-sovereign identity systems rely heavily on asymmetric cryptography to enable individuals to control their own digital identities without depending on centralized authorities. Public-private key pairs become the foundation of verifiable credentials and attestations.</p>
            </div>

            <div class="highlight-box">
                <h4>Layer 2 Privacy Solutions</h4>
                <p>Zero-knowledge proofs and other privacy-preserving technologies in Layer 2 solutions often combine symmetric encryption for data privacy with asymmetric cryptography for identity verification and proof generation.</p>
            </div>

            <h3>Course Roadmap</h3>
            
            <p>Our journey through cryptographic fundamentals follows this carefully structured path:</p>

            <ul>
                <li><span class="emoji">🔑</span><strong>Symmetric Cryptography Deep Dive</strong>
                    <ul>
                        <li>Historical evolution from Caesar ciphers to modern AES</li>
                        <li>Mathematical foundations and algorithm internals</li>
                        <li>Key management challenges and solutions</li>
                        <li>Performance characteristics and optimization techniques</li>
                        <li>Practical implementation in Node.js with security considerations</li>
                    </ul>
                </li>
                
                <li><span class="emoji">🗝️</span><strong>Asymmetric Cryptography Exploration</strong>
                    <ul>
                        <li>The revolutionary concept of public-key cryptography</li>
                        <li>RSA algorithm: from mathematical theory to practical implementation</li>
                        <li>Elliptic Curve Cryptography: the backbone of modern blockchain</li>
                        <li>Digital signatures and their role in blockchain consensus</li>
                        <li>Key generation, storage, and lifecycle management</li>
                    </ul>
                </li>
                
                <li><span class="emoji">🌍</span><strong>Blockchain and Web3 Integration</strong>
                    <ul>
                        <li>How Bitcoin uses cryptographic hash functions and digital signatures</li>
                        <li>Ethereum's approach to account-based cryptography</li>
                        <li>Smart contract security and cryptographic best practices</li>
                        <li>Cross-chain communication and cryptographic bridging</li>
                        <li>Privacy coins and advanced cryptographic techniques</li>
                    </ul>
                </li>
                
                <li><span class="emoji">🛠️</span><strong>Hands-On Implementation</strong>
                    <ul>
                        <li>Building a secure message encryption system</li>
                        <li>Creating and verifying digital signatures</li>
                        <li>Implementing a basic blockchain transaction system</li>
                        <li>Security auditing and vulnerability assessment</li>
                        <li>Performance benchmarking and optimization</li>
                    </ul>
                </li>
            </ul>

            <h3>Prerequisites and Preparation</h3>
            
            <p>To maximize your learning experience in this lesson, we recommend:</p>

            <ul>
                <li><strong>Basic Programming Knowledge:</strong> Familiarity with JavaScript/Node.js will be helpful for code examples, though all concepts will be explained thoroughly</li>
                <li><strong>Mathematical Foundation:</strong> Understanding of basic algebra and number theory will enhance comprehension of cryptographic algorithms</li>
                <li><strong>Curiosity and Critical Thinking:</strong> An inquisitive mindset ready to explore complex topics and ask "why" and "how" questions</li>
                <li><strong>Practical Orientation:</strong> Willingness to experiment with code examples and hands-on exercises</li>
            </ul>

            <p>Don't worry if you're new to cryptography—we'll build knowledge progressively, starting with fundamental concepts and advancing to sophisticated implementations.</p>

            <h3>Learning Methodology</h3>
            
            <p>This lesson employs a multi-modal learning approach designed to accommodate different learning styles:</p>

            <ul>
                <li><strong>Visual Learning:</strong> Comprehensive diagrams, flowcharts, and algorithm visualizations</li>
                <li><strong>Theoretical Understanding:</strong> In-depth explanations of mathematical principles and cryptographic theory</li>
                <li><strong>Practical Application:</strong> Hands-on coding exercises and real-world implementation examples</li>
                <li><strong>Comparative Analysis:</strong> Side-by-side comparisons and decision matrices</li>
                <li><strong>Assessment and Reflection:</strong> Interactive quizzes and thought-provoking questions</li>
            </ul>

            <p>Each section builds upon previous knowledge while introducing new concepts in a logical progression. Take your time to fully understand each concept before moving forward—cryptography rewards careful study and deep understanding.</p>

            <div class="success-box">
                <h4>Ready to Begin?</h4>
                <p>You're about to embark on a fascinating journey into the mathematical foundations that secure our digital world. The concepts you learn here will serve as building blocks for understanding advanced blockchain protocols, smart contract security, and the entire Web3 ecosystem. Let's dive in!</p>
            </div>
        </section>

        <div class="section-divider"></div>

        <!-- Section 2: Symmetric Cryptography -->
        <section id="symmetric-cryptography">
            <img src="img2.png" alt="Symmetric Cryptography Architecture and Implementation" class="lesson-image diagram-image">
            
            <h2><span class="emoji">🔑</span>Symmetric Cryptography: The Foundation of Secure Communication</h2>
            
            <h3>Fundamental Principles and Theory</h3>
            
            <p>Symmetric cryptography, also known as secret-key cryptography or private-key cryptography, represents one of humanity's oldest and most intuitive approaches to securing information. The fundamental principle is elegantly simple: the same key is used for both encryption and decryption processes. This shared secret forms the foundation of symmetric cryptographic systems and defines their primary characteristics.</p>

            <p>The mathematical representation of symmetric encryption can be expressed as:</p>

            <ul>
                <li><strong>Encryption:</strong> C = E(K, P) where C is ciphertext, E is the encryption function, K is the key, and P is plaintext</li>
                <li><strong>Decryption:</strong> P = D(K, C) where D is the decryption function</li>
                <li><strong>Key Property:</strong> D(K, E(K, P)) = P (the decryption of encrypted plaintext returns the original plaintext)</li>
            </ul>

            <p>This mathematical elegance, however, introduces the central challenge of symmetric cryptography: the key distribution problem. How do two parties who wish to communicate securely share the secret key without that key being intercepted by adversaries? This question has driven centuries of cryptographic innovation and remains relevant in modern digital communications.</p>

            <h3>Historical Context and Evolution</h3>
            
            <p>The history of symmetric cryptography spans millennia, from ancient substitution ciphers to modern computer-based algorithms. Understanding this evolution provides crucial context for appreciating current cryptographic systems.</p>

            <h4>Ancient Foundations</h4>
            
            <p>The earliest known symmetric ciphers date back to ancient civilizations. The Caesar cipher, attributed to Julius Caesar around 50 BCE, exemplifies the substitution cipher approach. Each letter in the plaintext is shifted a fixed number of positions in the alphabet. While trivially simple by modern standards, it demonstrates the core principle of transformation using a shared secret (the shift value).</p>

            <pre><code>// Simple Caesar Cipher Implementation
function caesarEncrypt(text, shift) {
    return text.split('').map(char => {
        if (char.match(/[a-z]/i)) {
            const code = char.charCodeAt(0);
            const base = code < 97 ? 65 : 97; // Uppercase or lowercase
            return String.fromCharCode(((code - base + shift) % 26) + base);
        }
        return char; // Non-alphabetic characters unchanged
    }).join('');
}

// Example usage
const plaintext = "HELLO WORLD";
const encrypted = caesarEncrypt(plaintext, 3); // "KHOOR ZRUOG"
const decrypted = caesarEncrypt(encrypted, -3); // "HELLO WORLD"</code></pre>

            <h4>Medieval and Renaissance Developments</h4>
            
            <p>The medieval period saw the development of more sophisticated substitution ciphers, including the Vigenère cipher (developed in the 16th century). This polyalphabetic cipher used a keyword to create multiple substitution alphabets, significantly increasing security compared to monoalphabetic ciphers like Caesar.</p>

            <h4>Industrial Age Innovations</h4>
            
            <p>The 19th and early 20th centuries brought mechanical encryption devices. The Enigma machine, used extensively during World War II, represented a significant advancement in symmetric cryptography. Its rotor-based design created billions of possible key combinations, though it was ultimately broken through a combination of mathematical analysis and computational power.</p>

            <h4>Computer Age Revolution</h4>
            
            <p>The advent of computers transformed symmetric cryptography. The Data Encryption Standard (DES), adopted by the U.S. government in 1977, marked the beginning of modern symmetric cryptography. DES used a 56-bit key and operated on 64-bit blocks of data, providing unprecedented security for its time.</p>

            <h3>Modern Symmetric Algorithms</h3>
            
            <h4>Advanced Encryption Standard (AES)</h4>
            
            <p>The Advanced Encryption Standard (AES), also known as Rijndael, represents the current gold standard in symmetric encryption. Adopted by the U.S. National Institute of Standards and Technology (NIST) in 2001, AES replaced DES and has become the most widely used symmetric encryption algorithm globally.</p>

            <p>AES operates on 128-bit blocks and supports key sizes of 128, 192, and 256 bits, corresponding to AES-128, AES-192, and AES-256 respectively. The algorithm's strength lies in its mathematical foundation based on finite field arithmetic and its resistance to known cryptanalytic attacks.</p>

            <img src="img3.png" alt="Advanced AES Implementation and Code Structure Analysis" class="lesson-image code-image">

            <h5>AES Algorithm Structure</h5>
            
            <p>AES consists of multiple rounds of transformation, with the number of rounds dependent on the key size:</p>

            <ul>
                <li><strong>AES-128:</strong> 10 rounds</li>
                <li><strong>AES-192:</strong> 12 rounds</li>
                <li><strong>AES-256:</strong> 14 rounds</li>
            </ul>

            <p>Each round (except the final round) consists of four operations:</p>

            <ol>
                <li><strong>SubBytes:</strong> Non-linear substitution using S-boxes</li>
                <li><strong>ShiftRows:</strong> Cyclic shifting of rows in the state matrix</li>
                <li><strong>MixColumns:</strong> Linear transformation mixing columns</li>
                <li><strong>AddRoundKey:</strong> XOR operation with the round key</li>
            </ol>

            <pre><code>// AES-256 Encryption Example using Node.js crypto module
const crypto = require('crypto');

class AESEncryption {
    constructor() {
        this.algorithm = 'aes-256-cbc';
        this.keyLength = 32; // 256 bits
        this.ivLength = 16;  // 128 bits
    }

    // Generate a secure random key
    generateKey() {
        return crypto.randomBytes(this.keyLength);
    }

    // Generate a secure random initialization vector
    generateIV() {
        return crypto.randomBytes(this.ivLength);
    }

    // Encrypt data with AES-256-CBC
    encrypt(plaintext, key) {
        try {
            const iv = this.generateIV();
            const cipher = crypto.createCipher(this.algorithm, key, iv);
            
            let encrypted = cipher.update(plaintext, 'utf8', 'hex');
            encrypted += cipher.final('hex');
            
            // Return IV prepended to encrypted data for decryption
            return iv.toString('hex') + ':' + encrypted;
        } catch (error) {
            throw new Error('Encryption failed: ' + error.message);
        }
    }

    // Decrypt AES-256-CBC encrypted data
    decrypt(encryptedData, key) {
        try {
            const parts = encryptedData.split(':');
            if (parts.length !== 2) {
                throw new Error('Invalid encrypted data format');
            }
            
            const iv = Buffer.from(parts[0], 'hex');
            const encrypted = parts[1];
            
            const decipher = crypto.createDecipher(this.algorithm, key, iv);
            
            let decrypted = decipher.update(encrypted, 'hex', 'utf8');
            decrypted += decipher.final('utf8');
            
            return decrypted;
        } catch (error) {
            throw new Error('Decryption failed: ' + error.message);
        }
    }

    // Demonstrate key derivation from password
    deriveKeyFromPassword(password, salt) {
        // Use PBKDF2 for key derivation
        return crypto.pbkdf2Sync(password, salt, 100000, this.keyLength, 'sha256');
    }
}

// Practical usage example
const aes = new AESEncryption();

// Method 1: Using random key
const randomKey = aes.generateKey();
const sensitiveData = "User private key: 0x1a2b3c4d5e6

// Method 1: Using random key
const randomKey = aes.generateKey();
const sensitiveData = "User private key: 0x1a2b3c4d5e6
