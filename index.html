I'll create a comprehensive, self-contained HTML5 page for the Web3 Odyssey lesson on Symmetric vs Asymmetric Cryptography. Let me start by exploring the workspace structure to understand the current setup.

Ran tool
It seems I'm in the root directory. Let me check if there's a specific workspace or project directory I should be working in.

Ran tool
Based on your requirements, I'll create a comprehensive HTML5 page for the Web3 Odyssey lesson. Since this will be placed in the GitHub repository, I'll create the complete self-contained HTML file with all the specifications you've outlined.

Here's the complete HTML5 page for "Web3 Odyssey – Module 1: Lesson 1.1 Symmetric vs Asymmetric Cryptography":

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Web3 Odyssey - Module 1: Lesson 1.1 | Symmetric vs Asymmetric Cryptography</title>
    <link rel="icon" href="favicon.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;700;900&family=Roboto:wght@300;400;500;700&family=Roboto+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: linear-gradient(135deg, #0a0e27 0%, #1a1f4b 50%, #0f1428 100%);
            --secondary-bg: linear-gradient(135deg, #1a1f4b 0%, #2a2f5b 100%);
            --accent-cyan: #00ffff;
            --accent-violet: #8a2be2;
            --accent-neon: #00ff88;
            --text-primary: #ffffff;
            --text-secondary: #b8c5d6;
            --text-muted: #8a9ba8;
            --border-glow: 0 0 20px rgba(0, 255, 255, 0.3);
            --shadow-glow: 0 8px 32px rgba(0, 255, 255, 0.15);
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Header Styles */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f4b 100%);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            box-shadow: var(--shadow-glow);
            z-index: 1000;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            height: 60px;
            width: auto;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5));
        }

        .header-text {
            text-align: right;
        }

        .header-title {
            font-family: 'Roboto Slab', serif;
            font-weight: 900;
            font-size: 1.8rem;
            background: linear-gradient(45deg, var(--accent-cyan), var(--accent-violet));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .header-subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        /* Main Container */
        .main-container {
            max-width: 1100px;
            margin: 120px auto 40px;
            padding: 40px;
            background: var(--secondary-bg);
            border-radius: 20px;
            box-shadow: var(--shadow-glow);
            border: 1px solid rgba(0, 255, 255, 0.1);
        }

        /* Typography */
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Roboto Slab', serif;
            font-weight: 700;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        h1 {
            font-size: 2.5rem;
            text-align: center;
            background: linear-gradient(45deg, var(--accent-cyan), var(--accent-violet));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
        }

        h2 {
            font-size: 2rem;
            color: var(--accent-cyan);
            border-left: 4px solid var(--accent-cyan);
            padding-left: 20px;
            margin-top: 40px;
        }

        h3 {
            font-size: 1.5rem;
            color: var(--accent-violet);
            margin-top: 30px;
        }

        p {
            margin-bottom: 20px;
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Images */
        .slide-image {
            width: 75%;
            max-width: 800px;
            height: auto;
            display: block;
            margin: 30px auto;
            border-radius: 15px;
            box-shadow: var(--border-glow);
            border: 2px solid rgba(0, 255, 255, 0.2);
        }

        /* Code Blocks */
        pre {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            box-shadow: var(--shadow-glow);
        }

        code {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            color: var(--accent-neon);
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
        }

        pre code {
            background: none;
            padding: 0;
            color: var(--text-primary);
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
            background: rgba(26, 31, 75, 0.5);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: var(--shadow-glow);
        }

        th {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet));
            color: #000;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            font-family: 'Roboto Slab', serif;
        }

        td {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            color: var(--text-secondary);
        }

        tr:hover {
            background: rgba(0, 255, 255, 0.05);
        }

        /* Blockquotes */
        blockquote {
            background: rgba(0, 255, 255, 0.05);
            border-left: 4px solid var(--accent-cyan);
            padding: 20px;
            margin: 30px 0;
            border-radius: 0 10px 10px 0;
            font-style: italic;
        }

        /* Links */
        a {
            color: var(--accent-cyan);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        a:hover {
            color: var(--accent-neon);
            text-shadow: 0 0 10px var(--accent-cyan);
        }

        /* Quiz Sections */
        .quiz-section {
            background: rgba(138, 43, 226, 0.1);
            border: 2px solid var(--accent-violet);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .quiz-question {
            font-weight: 600;
            color: var(--accent-violet);
            margin-bottom: 15px;
        }

        .quiz-options {
            list-style: none;
        }

        .quiz-options li {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quiz-options li:hover {
            background: rgba(0, 255, 255, 0.1);
            border-left: 3px solid var(--accent-cyan);
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 30px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            margin-top: 50px;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                padding: 10px 20px;
                flex-direction: column;
                gap: 10px;
            }

            .header-title {
                font-size: 1.4rem;
            }

            .main-container {
                margin: 140px 20px 20px;
                padding: 20px;
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.6rem;
            }

            .slide-image {
                width: 95%;
            }

            table {
                font-size: 0.9rem;
            }

            th, td {
                padding: 10px;
            }
        }

        @media (max-width: 480px) {
            .header-title {
                font-size: 1.2rem;
            }

            .main-container {
                margin: 160px 10px 10px;
                padding: 15px;
            }

            h1 {
                font-size: 1.8rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            p {
                font-size: 1rem;
            }
        }

        /* Animations */
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); }
        }

        .glow-effect {
            animation: glow 3s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <img src="logo.png" alt="MOKSHA Innovators Guild" class="logo">
        <div class="header-text">
            <div class="header-title">Web3 Odyssey</div>
            <div class="header-subtitle">Module 1: Foundations | Lesson 1.1 Symmetric vs Asymmetric Cryptography</div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="main-container">
        <!-- Lesson Introduction -->
        <h1>🔐 Symmetric vs Asymmetric Cryptography</h1>
        
        <p>Welcome to the foundational lesson of Web3 Odyssey! In this comprehensive exploration, we'll dive deep into the two fundamental approaches to cryptography that power the entire Web3 ecosystem. Understanding the difference between symmetric and asymmetric cryptography is crucial for anyone serious about blockchain development, smart contract security, and decentralized applications.</p>

        <blockquote>
            "Cryptography is the foundation upon which the entire Web3 ecosystem is built. Without it, there would be no secure transactions, no digital signatures, and no trust in the decentralized world." — MOKSHA Innovators Guild
        </blockquote>

        <h2>🎯 Learning Objectives</h2>
        <p>By the end of this lesson, you will be able to:</p>
        <ul>
            <li>Understand the fundamental differences between symmetric and asymmetric cryptography</li>
            <li>Implement both encryption methods using Node.js</li>
            <li>Analyze real-world Web3 use cases for each approach</li>
            <li>Evaluate security trade-offs and performance considerations</li>
            <li>Apply cryptographic principles to smart contract development</li>
        </ul>

        <!-- Slide 1: Introduction to Cryptography -->
        <h2>📚 Slide 1: The Foundation of Digital Security</h2>
        <img src="img1.png" alt="Cryptography Foundation" class="slide-image">
        
        <p>Cryptography is the science of secure communication in the presence of adversaries. It's the mathematical foundation that enables trust in the digital world. In Web3, cryptography is not just a tool—it's the very fabric that holds the decentralized ecosystem together.</p>

        <p>At its core, cryptography solves three fundamental problems:</p>
        <ol>
            <li><strong>Confidentiality:</strong> Ensuring that only authorized parties can read the information</li>
            <li><strong>Integrity:</strong> Guaranteeing that the information hasn't been tampered with</li>
            <li><strong>Authentication:</strong> Verifying the identity of the parties involved</li>
        </ol>

        <p>In the context of Web3, these principles are applied to create secure digital wallets, verify smart contract interactions, and establish trust in decentralized networks without relying on central authorities.</p>

        <!-- Slide 2: Symmetric Encryption Theory -->
        <h2>�� Slide 2: Symmetric Encryption - The Shared Secret</h2>
        <img src="img2.png" alt="Symmetric Encryption" class="slide-image">
        
        <p>Symmetric encryption, also known as secret-key encryption, uses the same key for both encryption and decryption. This approach is like having a single key that both locks and unlocks a treasure chest. The key must be kept secret and shared securely between the communicating parties.</p>

        <p>The mathematical foundation of symmetric encryption relies on complex algorithms that transform plaintext into ciphertext using the secret key. Popular symmetric encryption algorithms include:</p>

        <ul>
            <li><strong>AES (Advanced Encryption Standard):</strong> The gold standard for symmetric encryption, supporting key sizes of 128, 192, and 256 bits</li>
            <li><strong>ChaCha20:</strong> A modern stream cipher designed for high performance and security</li>
            <li><strong>3DES (Triple Data Encryption Standard):</strong> A legacy algorithm that applies DES three times for enhanced security</li>
        </ul>

        <p>The strength of symmetric encryption lies in its simplicity and speed. Since the same key is used for both operations, the computational overhead is minimal, making it ideal for encrypting large amounts of data efficiently.</p>

        <!-- Slide 3: Symmetric Encryption Code Example -->
        <h2>💻 Slide 3: Implementing Symmetric Encryption in Node.js</h2>
        <img src="img3.png" alt="Symmetric Code Example" class="slide-image">
        
        <p>Let's implement AES-256-GCM symmetric encryption using Node.js. This example demonstrates how to encrypt and decrypt data with authentication, ensuring both confidentiality and integrity.</p>

        <pre><code>const crypto = require('crypto');

class SymmetricEncryption {
    constructor() {
        this.algorithm = 'aes-256-gcm';
        this.keyLength = 32; // 256 bits
        this.ivLength = 16;  // 128 bits
        this.tagLength = 16; // 128 bits
    }

    // Generate a random encryption key
    generateKey() {
        return crypto.randomBytes(this.keyLength);
    }

    // Encrypt data using AES-256-GCM
    encrypt(plaintext, key) {
        const iv = crypto.randomBytes(this.ivLength);
        const cipher = crypto.createCipher(this.algorithm, key);
        cipher.setAAD(Buffer.from('web3-odyssey', 'utf8')); // Additional authenticated data
        
        let encrypted = cipher.update(plaintext, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        const tag = cipher.getAuthTag();
        
        return {
            encrypted: encrypted,
            iv: iv.toString('hex'),
            tag: tag.toString('hex'),
            algorithm: this.algorithm
        };
    }

    // Decrypt data using AES-256-GCM
    decrypt(encryptedData, key) {
        const decipher = crypto.createDecipher(this.algorithm, key);
        decipher.setAAD(Buffer.from('web3-odyssey', 'utf8'));
        decipher.setAuthTag(Buffer.from(encryptedData.tag, 'hex'));
        
        let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }
}

// Usage example
const crypto = new SymmetricEncryption();
const secretKey = crypto.generateKey();
const message = "Hello, Web3 World!";

console.log("Original message:", message);

const encrypted = crypto.encrypt(message, secretKey);
console.log("Encrypted data:", encrypted);

const decrypted = crypto.decrypt(encrypted, secretKey);
console.log("Decrypted message:", decrypted);</code></pre>

        <p>This implementation uses AES-256-GCM, which provides both encryption and authentication. The GCM (Galois/Counter Mode) ensures that any tampering with the encrypted data will be detected during decryption.</p>

        <!-- Slide 4: Symmetric Encryption Pros & Cons -->
        <h2>⚖️ Slide 4: Symmetric Encryption Analysis</h2>
        <img src="img4.png" alt="Symmetric Analysis" class="slide-image">
        
        <table>
            <thead>
                <tr>
                    <th>Advantages</th>
                    <th>Disadvantages</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>⚡ High performance and speed</td>
                    <td>🔑 Key distribution problem</td>
                </tr>
                <tr>
                    <td>🔒 Strong security with proper key management</td>
                    <td>👥 Requires secure key exchange</td>
                </tr>
                <tr>
                    <td>💾 Efficient for large data volumes</td>
                    <td>🔐 Key management complexity</td>
                </tr>
                <tr>
                    <td>🔄 Simple implementation</td>
                    <td>❌ No built-in authentication</td>
                </tr>
                <tr>
                    <td>🎯 Low computational overhead</td>
                    <td>🔍 Vulnerable to key compromise</td>
                </tr>
            </tbody>
        </table>

        <p>The key distribution problem is the Achilles' heel of symmetric encryption. How do you securely share the secret key with someone you've never met? This fundamental limitation led to the development of asymmetric cryptography.</p>

        <!-- Quiz 1 -->
        <div class="quiz-section">
            <h3>🧠 Quick Quiz 1: Symmetric Encryption</h3>
            <p class="quiz-question">Which of the following is the primary challenge with symmetric encryption?</p>
            <ul class="quiz-options">
                <li>A) Computational complexity</li>
                <li>B) Key distribution and management</li>
                <li>C) Encryption speed</li>
                <li>D) Algorithm strength</li>
            </ul>
            <p><strong>Answer:</strong> B) Key distribution and management. The main challenge is securely sharing the secret key between parties without it being intercepted.</p>
        </div>

        <!-- Slide 5: Asymmetric Encryption Theory -->
        <h2>🔐 Slide 5: Asymmetric Encryption - The Key Pair Revolution</h2>
        <img src="img5.png" alt="Asymmetric Encryption" class="slide-image">
        
        <p>Asymmetric encryption, also known as public-key cryptography, uses a pair of mathematically related keys: a public key for encryption and a private key for decryption. This revolutionary approach solves the key distribution problem that plagued symmetric encryption.</p>

        <p>The mathematical foundation of asymmetric encryption is based on complex mathematical problems that are easy to solve in one direction but computationally infeasible to reverse. The most common approaches are:</p>

        <ul>
            <li><strong>RSA (Rivest-Shamir-Adleman):</strong> Based on the difficulty of factoring large prime numbers</li>
            <li><strong>ECC (Elliptic Curve Cryptography):</strong> Based on the discrete logarithm problem in elliptic curve groups</li>
            <li><strong>ElGamal:</strong> Based on the Diffie-Hellman key exchange protocol</li>
        </ul>

        <p>In Web3, ECC is particularly important because it provides the same security level as RSA with much smaller key sizes, making it ideal for blockchain applications where efficiency is crucial.</p>

        <!-- Slide 6: Asymmetric Encryption Code Example -->
        <h2>💻 Slide 6: Implementing Asymmetric Encryption in Node.js</h2>
        <img src="img6.png" alt="Asymmetric Code Example" class="slide-image">
        
        <p>Let's implement RSA asymmetric encryption using Node.js. This example shows how to generate key pairs, encrypt data with a public key, and decrypt it with the corresponding private key.</p>

        <pre><code>const crypto = require('crypto');

class AsymmetricEncryption {
    constructor() {
        this.algorithm = 'rsa';
        this.keySize = 2048;
        this.encryptionScheme = 'oaep';
        this.hashAlgorithm = 'sha256';
    }

    // Generate RSA key pair
    generateKeyPair() {
        return new Promise((resolve, reject) => {
            crypto.generateKeyPair(this.algorithm, {
                modulusLength: this.keySize,
                publicKeyEncoding: {
                    type: 'spki',
                    format: 'pem'
                },
                privateKeyEncoding: {
                    type: 'pkcs8',
                    format: 'pem'
                }
            }, (err, publicKey, privateKey) => {
                if (err) reject(err);
                else resolve({ publicKey, privateKey });
            });
        });
    }

    // Encrypt data using public key
    encrypt(plaintext, publicKey) {
        const buffer = Buffer.from(plaintext, 'utf8');
        const encrypted = crypto.publicEncrypt({
            key: publicKey,
            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
            oaepHash: this.hashAlgorithm
        }, buffer);
        
        return encrypted.toString('base64');
    }

    // Decrypt data using private key
    decrypt(encryptedData, privateKey) {
        const buffer = Buffer.from(encryptedData, 'base64');
        const decrypted = crypto.privateDecrypt({
            key: privateKey,
            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
            oaepHash: this.hashAlgorithm
        }, buffer);
        
        return decrypted.toString('utf8');
    }

    // Create digital signature
    sign(data, privateKey) {
        const sign = crypto.createSign('SHA256');
        sign.update(data);
        sign.end();
        return sign.sign(privateKey, 'base64');
    }

    // Verify digital signature
    verify(data, signature, publicKey) {
        const verify = crypto.createVerify('SHA256');
        verify.update(data);
        verify.end();
        return verify.verify(publicKey, signature, 'base64');
    }
}

// Usage example
async function demonstrateAsymmetricEncryption() {
    const crypto = new AsymmetricEncryption();
    
    // Generate key pair
    const { publicKey, privateKey } = await crypto.generateKeyPair();
    console.log("Generated RSA key pair");
    
    const message = "Secure Web3 Communication";
    console.log("Original message:", message);
    
    // Encrypt with public key
    const encrypted = crypto.encrypt(message, publicKey);
    console.log("Encrypted data:", encrypted);
    
    // Decrypt with private key
    const decrypted = crypto.decrypt(encrypted, privateKey);
    console.log("Decrypted message:", decrypted);
    
    // Digital signature
    const signature = crypto.sign(message, privateKey);
    console.log("Digital signature:", signature);
    
    // Verify signature
    const isValid = crypto.verify(message, signature, publicKey);
    console.log("Signature valid:", isValid);
}

demonstrateAsymmetricEncryption().catch(console.error);</code></pre>

        <p>This implementation demonstrates both encryption/decryption and digital signatures, which are fundamental to Web3 applications. Digital signatures prove authenticity and integrity without revealing the private key.</p>

        <!-- Slide 7: Asymmetric Encryption Pros & Cons -->
        <h2>⚖️ Slide 7: Asymmetric Encryption Analysis</h2>
        <img src="img7.png" alt="Asymmetric Analysis" class="slide-image">
        
        <table>
            <thead>
                <tr>
                    <th>Advantages</th>
                    <th>Disadvantages</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>🔑 Solves key distribution problem</td>
                    <td>🐌 Slower than symmetric encryption</td>
                </tr>
                <tr>
                    <td>✍️ Enables digital signatures</td>
                    <td>💾 Larger key sizes required</td>
                </tr>
                <tr>
                    <td>🔐 Built-in authentication</td>
                    <td>⚡ Higher computational overhead</td>
                </tr>
                <tr>
                    <td>🌐 Perfect for key exchange</td>
                    <td>📊 Limited data size for encryption</td>
                </tr>
                <tr>
                    <td>🛡️ Non-repudiation support</td>
                    <td>🔍 Vulnerable to quantum attacks</td>
                </tr>
            </tbody>
        </table>

        <p>The performance trade-off is significant: asymmetric encryption is typically 100-1000 times slower than symmetric encryption. This is why hybrid systems that combine both approaches are commonly used in practice.</p>

        <!-- Quiz 2 -->
        <div class="quiz-section">
            <h3>🧠 Quick Quiz 2: Asymmetric Encryption</h3>
            <p class="quiz-question">What is the primary advantage of asymmetric encryption over symmetric encryption?</p>
            <ul class="quiz-options">
                <li>A) Faster encryption speed</li>
                <li>B) Smaller key sizes</li>
                <li>C) Solves the key distribution problem</li>
                <li>D) Lower computational overhead</li>
            </ul>
            <p><strong>Answer:</strong> C) Solves the key distribution problem. Asymmetric encryption eliminates the need to securely share secret keys.</p>
        </div>

        <!-- Slide 8: Web3 Use Cases -->
        <h2>🌐 Slide 8: Real-World Web3 Applications</h2>
        <img src="img8.png" alt="Web3 Use Cases" class="slide-image">
        
        <p>In the Web3 ecosystem, both symmetric and asymmetric cryptography play crucial roles, often working together in hybrid systems. Let's explore the most important applications:</p>

        <h3>�� Digital Wallets</h3>
        <p>Cryptocurrency wallets use asymmetric cryptography extensively. When you create a wallet, a private/public key pair is generated. The public key is derived from the private key and serves as your wallet address. The private key is used to sign transactions, proving ownership of the funds.</p>

        <pre><code>// Simplified wallet key generation
const crypto = require('crypto');
const secp256k1 = require('secp256k1');

class Web3Wallet {
    generateWallet() {
        let privateKey;
        do {
            privateKey = crypto.randomBytes(32);
        } while (!secp256k1.privateKeyVerify(privateKey));
        
        const publicKey = secp256k1.publicKeyCreate(privateKey);
        const address = this.generateAddress(publicKey);
        
        return {
            privateKey: privateKey.toString('hex'),
            publicKey: publicKey.toString('hex'),
            address: address
        };
    }
    
    signTransaction(transaction, privateKey) {
        const messageHash = crypto.createHash('sha256')
            .update(JSON.stringify(transaction))
            .digest();
        
        const signature = secp256k1.sign(messageHash, Buffer.from(privateKey, 'hex'));
        return signature.signature.toString('hex');
    }
}</code></pre>

        <h3>�� Smart Contracts</h3>
        <p>Smart contracts use cryptographic signatures to verify that transactions are authorized by the correct parties. This prevents unauthorized modifications and ensures the integrity of the contract logic.</p>

        <h3>🔗 Blockchain Consensus</h3>
        <p>Proof-of-Work and Proof-of-Stake consensus mechanisms rely on cryptographic puzzles and digital signatures to maintain network security and prevent double-spending attacks.</p>

        <!-- Slide 9: Hybrid Cryptography Systems -->
        <h2>🔄 Slide 9: Hybrid Cryptography - The Best of Both Worlds</h2>
        <img src="img9.png" alt="Hybrid Cryptography" class="slide-image">
        
        <p>Modern Web3 applications typically use hybrid cryptography systems that combine the strengths of both symmetric and asymmetric encryption. This approach provides optimal security and performance.</p>

        <p>The typical hybrid workflow is:</p>
        <ol>
            <li><strong>Key Exchange:</strong> Use asymmetric encryption to securely exchange a symmetric session key</li>
            <li><strong>Data Encryption:</strong> Use the symmetric key for fast encryption of the actual data</li>
            <li><strong>Authentication:</strong> Use digital signatures to verify the identity of the parties</li>
        </ol>

        <pre><code>class HybridCryptography {
    constructor() {
        this.symmetricCrypto = new SymmetricEncryption();
        this.asymmetricCrypto = new AsymmetricEncryption();
    }

    async secureCommunication(senderPrivateKey, receiverPublicKey, message) {
        // Step 1: Generate a random symmetric session key
        const sessionKey = this.symmetricCrypto.generateKey();
        
        // Step 2: Encrypt the session key with receiver's public key
        const encryptedSessionKey = this.asymmetricCrypto.encrypt(
            sessionKey.toString('hex'), 
            receiverPublicKey
        );
        
        // Step 3: Encrypt the message with the session key
        const encryptedMessage = this.symmetricCrypto.encrypt(message, sessionKey);
        
        // Step 4: Sign the encrypted message with sender's private key
        const signature = this.asymmetricCrypto.sign(
            encryptedMessage.encrypted, 
            senderPrivateKey
        );
        
        return {
            encryptedSessionKey,
            encryptedMessage,
            signature,
            timestamp: Date.now()
        };
    }
}</code></pre>

        <p>This hybrid approach is used in protocols like TLS/SSL, which secure most web communications, and in blockchain networks for secure peer-to-peer communication.</p>

        <!-- Quiz 3 -->
        <div class="quiz-section">
            <h3>🧠 Quick Quiz 3: Hybrid Systems</h3>
            <p class="quiz-question">Why do hybrid cryptography systems use asymmetric encryption for key exchange and symmetric encryption for data?</p>
            <ul class="quiz-options">
                <li>A) Asymmetric encryption is more secure</li>
                <li>B) Symmetric encryption is faster for large data</li>
                <li>C) It's easier to implement</li>
                <li>D) Both A and B</li>
            </ul>
            <p><strong>Answer:</strong> D) Both A and B. Asymmetric encryption solves the key distribution problem, while symmetric encryption provides faster performance for large data volumes.</p>
        </div>

        <!-- Slide 10: Security Considerations -->
        <h2>🛡️ Slide 10: Security Best Practices & Considerations</h2>
        <img src="img10.png" alt="Security Considerations" class="slide-image">
        
        <p>Implementing cryptography correctly is challenging, and even small mistakes can lead to catastrophic security failures. Here are the critical considerations for Web3 developers:</p>

        <h3>�� Key Management</h3>
        <ul>
            <li><strong>Key Generation:</strong> Always use cryptographically secure random number generators</li>
            <li><strong>Key Storage:</strong> Never store private keys in plain text or in version control</li>
            <li><strong>Key Rotation:</strong> Regularly update keys to limit exposure from potential breaches</li>
            <li><strong>Key Backup:</strong> Implement secure backup strategies for critical keys</li>
        </ul>

        <h3>🔒 Algorithm Selection</h3>
        <table>
            <thead>
                <tr>
                    <th>Use Case</th>
                    <th>Recommended Algorithm</th>
                    <th>Key Size</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>General Encryption</td>
                    <td>AES-256-GCM</td>
                    <td>256 bits</td>
                </tr>
                <tr>
                    <td>Digital Signatures</td>
                    <td>ECDSA with secp256k1</td>
                    <td>256 bits</td>
                </tr>
                <tr>
                    <td>Key Exchange</td>
                    <td>ECDH with secp256k1</td>
                    <td>256 bits</td>
                </tr>
                <tr>
                    <td>Hash Functions</td>
                    <td>SHA-256 or SHA-3</td>
                    <td>256 bits</td>
                </tr>
            </tbody>
        </table>

        <h3>⚠️ Common Pitfalls</h3>
        <blockquote>
            <strong>Never:</strong> Implement your own cryptographic algorithms, use weak random number generators, store keys insecurely, or ignore algorithm deprecation warnings.
        </blockquote>

        <!-- Quiz 4 -->
        <div class="quiz-section">
            <h3>🧠 Quick Quiz 4: Security Best Practices</h3>
            <p class="quiz-question">Which of the following is the most critical security consideration for Web3 developers?</p>
            <ul class="quiz-options">
                <li>A) Using the fastest encryption algorithm</li>
                <li>B) Implementing custom cryptographic functions</li>
                <li>C) Proper key management and secure storage</li>
                <li>D) Using the smallest possible key sizes</li>
            </ul>
            <p><strong>Answer:</strong> C) Proper key management and secure storage. Even the strongest algorithms are useless if keys are compromised.</p>
        </div>

        <!-- Hands-On Exercise -->
        <h2>��️ Hands-On Exercise: Building a Secure Web3 Communication System</h2>
        <p>Now it's time to put your knowledge into practice! You'll build a simple but secure communication system that demonstrates both symmetric and asymmetric cryptography.</p>

        <h3>Exercise Requirements:</h3>
        <ol>
            <li>Create a Node.js application that implements hybrid cryptography</li>
            <li>Generate RSA key pairs for two users (Alice and Bob)</li>
            <li>Implement secure message exchange using the hybrid approach</li>
            <li>Add digital signature verification</li>
            <li>Include error handling and security validation</li>
        </ol>

        <pre><code>// Complete exercise solution
const crypto = require('crypto');

class SecureWeb3Communication {
    constructor() {
        this.algorithm = 'aes-256-gcm';
        this.rsaKeySize = 2048;
    }

    async generateUserKeys() {
        return new Promise((resolve, reject) => {
            crypto.generateKeyPair('rsa', {
                modulusLength: this.rsaKeySize,
                publicKeyEncoding: { type: 'spki', format: 'pem' },
                privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
            }, (err, publicKey, privateKey) => {
                if (err) reject(err);
                else resolve({ publicKey, privateKey });
            });
        });
    }

    async secureMessageExchange(senderPrivateKey, receiverPublicKey, message) {
        // Generate session key
        const sessionKey = crypto.randomBytes(32);
        
        // Encrypt session key with receiver's public key
        const encryptedSessionKey = crypto.publicEncrypt({
            key: receiverPublicKey,
            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
            oaepHash: 'sha256'
        }, sessionKey);
        
        // Encrypt message with session key
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipher(this.algorithm, sessionKey);
        let encryptedMessage = cipher.update(message, 'utf8', 'hex');
        encryptedMessage += cipher.final('hex');
        const authTag = cipher.getAuthTag();
        
        // Sign the encrypted message
        const sign = crypto.createSign('SHA256');
        sign.update(encryptedMessage);
        sign.end();
        const signature = sign.sign(senderPrivateKey, 'base64');
        
        return {
            encryptedSessionKey: encryptedSessionKey.toString('base64'),
            encryptedMessage,
            iv: iv.toString('hex'),
            authTag: authTag.toString('hex'),
            signature
        };
    }

    async decryptMessage(receiverPrivateKey, senderPublicKey, encryptedData) {
        // Decrypt session key
        const sessionKey = crypto.privateDecrypt({
            key: receiverPrivateKey,
            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
            oaepHash: 'sha256'
        }, Buffer.from(encryptedData.encryptedSessionKey, 'base64'));
        
        // Verify signature
        const verify = crypto.createVerify('SHA256');
        verify.update(encryptedData.encryptedMessage);
        verify.end();
        const isValid = verify.verify(senderPublicKey, encryptedData.signature, 'base64');
        
        if (!isValid) {
            throw new Error('Message signature verification failed');
        }
        
        // Decrypt message
        const decipher = crypto.createDecipher(this.algorithm, sessionKey);
        decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
        
        let decrypted = decipher.update(encryptedData.encryptedMessage, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }
}

// Demo usage
async function runExercise() {
    const comm = new SecureWeb3Communication();
    
    // Generate keys for Alice and Bob
    const aliceKeys = await comm.generateUserKeys();
    const bobKeys = await comm.generateUserKeys();
    
    console.log('Generated key pairs for Alice and Bob');
    
    // Alice sends a secure message to Bob
    const message = "Hello Bob! This is a secure Web3 message.";
    console.log('Original message:', message);
    
    const encrypted = await comm.secureMessageExchange(
        aliceKeys.privateKey,
        bobKeys.publicKey,
        message
    );
    console.log('Encrypted data sent to Bob');
    
    // Bob decrypts and verifies the message
    const decrypted = await comm.decryptMessage(
        bobKeys.privateKey,
        aliceKeys.publicKey,
        encrypted
    );
    console.log('Decrypted message:', decrypted);
    console.log('Message verified successfully!');
}

runExercise().catch(console.error);</code></pre>

        <!-- Quiz 5 -->
        <div class="quiz-section">
            <h3>🧠 Final Quiz: Comprehensive Understanding</h3>
            <p class="quiz-question">In the hybrid cryptography system we just implemented, what is the purpose of the digital signature?</p>
            <ul class="quiz-options">
                <li>A) To encrypt the message</li>
                <li>B) To verify the sender's identity and message integrity</li>
                <li>C) To generate the session key</li>
                <li>D) To compress the data</li>
            </ul>
            <p><strong>Answer:</strong> B) To verify the sender's identity and message integrity. Digital signatures provide authentication and non-repudiation.</p>
        </div>

        <!-- Summary -->
        <h2>📋 Summary & Key Takeaways</h2>
        <p>Congratulations! You've completed the foundational lesson on symmetric vs asymmetric cryptography. Here's what we've covered:</p>

        <h3>🔑 Symmetric Cryptography</h3>
        <ul>
            <li>Uses the same key for encryption and decryption</li>
            <li>Fast and efficient for large data volumes</li>
            <li>Suffers from the key distribution problem</li>
            <li>Best for: Bulk data encryption, session keys</li>
        </ul>

        <h3>🔐 Asymmetric Cryptography</h3>
        <ul>
            <li>Uses public/private key pairs</li>
            <li>Solves the key distribution problem</li>
            <li>Enables digital signatures and authentication</li>
            <li>Slower but more flexible than symmetric</li>
        </ul>

        <h3>�� Hybrid Systems</h3>
        <ul>
            <li>Combine the best of both approaches</li>
            <li>Use asymmetric for key exchange</li>
            <li>Use symmetric for data encryption</li>
            <li>Standard in modern Web3 applications</li>
        </ul>

        <h3>🛡️ Security Best Practices</h3>
        <ul>
            <li>Always use established, well-tested algorithms</li>
            <li>Implement proper key management</li>
            <li>Never store private keys insecurely</li>
            <li>Regularly update and rotate keys</li>
        </ul>

        <!-- Further Reading -->
        <h2>📚 Further Reading & Resources</h2>
        <p>To deepen your understanding of cryptography in Web3, explore these resources:</p>

        <h3>�� Books</h3>
        <ul>
            <li><strong>"Applied Cryptography"</strong> by Bruce Schneier</li>
            <li><strong>"Cryptography Engineering"</strong> by Ferguson, Schneier, and Kohno</li>
            <li><strong>"Mastering Bitcoin"</strong> by Andreas Antonopoulos</li>
        </ul>

        <h3>�� Online Resources</h3>
        <ul>
            <li><a href="https://cryptography.io/" target="_blank">Cryptography.io</a> - Python cryptography library</li>
            <li><a href="https://nodejs.org/api/crypto.html" target="_blank">Node.js Crypto Module</a> - Official documentation</li>
            <li><a href="https://www.nist.gov/cryptography" target="_blank">NIST Cryptography Standards</a> - Government standards</li>
        </ul>

        <h3>�� Research Papers</h3>
        <ul>
            <li>"Bitcoin: A Peer-to-Peer Electronic Cash System" by Satoshi Nakamoto</li>
            <li>"Elliptic Curve Cryptography" by Koblitz and Menezes</li>
            <li>"The Mathematics of the RSA Public-Key Cryptosystem" by Rivest</li>
        </ul>

        <!-- Closing Note -->
        <blockquote style="background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(138, 43, 226, 0.1)); border-left: 4px solid var(--accent-violet);">
            <h3 style="color: var(--accent-violet); margin-bottom: 15px;">�� A Message from MOKSHA Innovators Guild</h3>
            <p>You've taken the first crucial step in your Web3 journey. Cryptography is not just a technical skill—it's the foundation of trust in the decentralized world. As you continue your exploration, remember that with great cryptographic power comes great responsibility. Use these tools wisely to build a more secure, transparent, and equitable digital future.</p>
            <p style="margin-top: 15px; font-weight: 600;">The future of Web3 is in your hands. Build it securely. Build it r
