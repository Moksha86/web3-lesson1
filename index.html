I'll create a comprehensive, self-contained HTML5 page for the Web3 Odyssey lesson. Let me start by exploring the workspace to understand the current structure.

Ran tool
Based on your requirements, I'll create a comprehensive HTML5 page for the Web3 Odyssey lesson. Here's the complete self-contained HTML file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Web3 Odyssey - Module 1: Lesson 1.1 | Symmetric vs Asymmetric Cryptography</title>
    <link rel="icon" href="./favicon.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;700;900&family=Roboto:wght@300;400;500;700&family=Roboto+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: linear-gradient(135deg, #0a0e27 0%, #1a1f4b 50%, #0f1428 100%);
            --secondary-bg: linear-gradient(135deg, #1a1f4b 0%, #2a2f5b 100%);
            --accent-cyan: #00ffff;
            --accent-violet: #8a2be2;
            --accent-neon: #00ff88;
            --text-primary: #ffffff;
            --text-secondary: #b8c5d6;
            --text-muted: #8a9ba8;
            --border-glow: 0 0 20px rgba(0, 255, 255, 0.3);
            --shadow-glow: 0 8px 32px rgba(0, 255, 255, 0.15);
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Header Styles */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f4b 100%);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            box-shadow: var(--shadow-glow);
            z-index: 1000;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 80px;
        }

        .logo {
            height: 60px;
            width: 60px;
            object-fit: contain;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5));
            border-radius: 8px;
        }

        .header-text {
            text-align: right;
            flex: 1;
            margin-left: 20px;
        }

        .header-title {
            font-family: 'Roboto Slab', serif;
            font-weight: 900;
            font-size: 1.8rem;
            background: linear-gradient(45deg, var(--accent-cyan), var(--accent-violet));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .header-subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        /* Navigation */
        .nav-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .nav-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
            white-space: nowrap;
        }

        .nav-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        /* Main Container */
        .main-container {
            max-width: 1100px;
            margin: 100px auto 40px;
            padding: 40px;
            background: var(--secondary-bg);
            border-radius: 20px;
            box-shadow: var(--shadow-glow);
            border: 1px solid rgba(0, 255, 255, 0.1);
        }

        /* Typography */
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Roboto Slab', serif;
            font-weight: 700;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        h1 {
            font-size: 2.5rem;
            text-align: center;
            background: linear-gradient(45deg, var(--accent-cyan), var(--accent-violet));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
        }

        h2 {
            font-size: 2rem;
            color: var(--accent-cyan);
            border-left: 4px solid var(--accent-cyan);
            padding-left: 20px;
            margin-top: 40px;
        }

        h3 {
            font-size: 1.5rem;
            color: var(--accent-violet);
            margin-top: 30px;
        }

        p {
            margin-bottom: 20px;
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Images */
        .slide-image {
            width: 75%;
            max-width: 800px;
            height: auto;
            display: block;
            margin: 30px auto;
            border-radius: 15px;
            box-shadow: var(--border-glow);
            border: 2px solid rgba(0, 255, 255, 0.2);
        }

        /* Code Blocks */
        pre {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            box-shadow: var(--shadow-glow);
        }

        code {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            color: var(--accent-neon);
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
        }

        pre code {
            background: none;
            padding: 0;
            color: var(--text-primary);
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
            background: rgba(26, 31, 75, 0.5);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: var(--shadow-glow);
        }

        th {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet));
            color: #000;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            font-family: 'Roboto Slab', serif;
        }

        td {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            color: var(--text-secondary);
        }

        tr:hover {
            background: rgba(0, 255, 255, 0.05);
        }

        /* Blockquotes */
        blockquote {
            background: rgba(0, 255, 255, 0.05);
            border-left: 4px solid var(--accent-cyan);
            padding: 20px;
            margin: 30px 0;
            border-radius: 0 10px 10px 0;
            font-style: italic;
        }

        /* Links */
        a {
            color: var(--accent-cyan);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        a:hover {
            color: var(--accent-neon);
            text-shadow: 0 0 10px var(--accent-cyan);
        }

        /* Quiz Sections */
        .quiz-section {
            background: rgba(138, 43, 226, 0.1);
            border: 2px solid var(--accent-violet);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .quiz-question {
            font-weight: 600;
            color: var(--accent-violet);
            margin-bottom: 15px;
        }

        .quiz-options {
            list-style: none;
        }

        .quiz-options li {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quiz-options li:hover {
            background: rgba(0, 255, 255, 0.1);
            border-left: 3px solid var(--accent-cyan);
        }

        /* Info Tags */
        .info-tags {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .info-tag {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: var(--accent-cyan);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 30px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            margin-top: 50px;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                padding: 10px 20px;
                height: 70px;
            }

            .header-title {
                font-size: 1.4rem;
            }

            .header-subtitle {
                font-size: 0.8rem;
            }

            .nav-buttons {
                gap: 5px;
            }

            .nav-btn {
                padding: 4px 8px;
                font-size: 0.7rem;
            }

            .main-container {
                margin: 90px 20px 20px;
                padding: 20px;
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.6rem;
            }

            .slide-image {
                width: 95%;
            }

            table {
                font-size: 0.9rem;
            }

            th, td {
                padding: 10px;
            }
        }

        @media (max-width: 480px) {
            .header {
                height: 60px;
                padding: 8px 15px;
            }

            .header-title {
                font-size: 1.2rem;
            }

            .header-subtitle {
                font-size: 0.7rem;
            }

            .nav-buttons {
                display: none;
            }

            .main-container {
                margin: 80px 10px 10px;
                padding: 15px;
            }

            h1 {
                font-size: 1.8rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            p {
                font-size: 1rem;
            }
        }

        /* Animations */
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); }
        }

        .glow-effect {
            animation: glow 3s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <img src="./logo.png" alt="MOKSHA Innovators Guild" class="logo">
        <div class="header-text">
            <div class="header-title">Web3 Odyssey</div>
            <div class="header-subtitle">Module 1: Foundations | Lesson 1.1 Symmetric vs Asymmetric Cryptography</div>
            <div class="nav-buttons">
                <a href="#intro" class="nav-btn">Intro</a>
                <a href="#symmetric-theory" class="nav-btn">Symmetric Theory</a>
                <a href="#symmetric-code" class="nav-btn">Symmetric Code</a>
                <a href="#symmetric-pros-cons" class="nav-btn">Symmetric Pros/Cons</a>
                <a href="#asymmetric-theory" class="nav-btn">Asymmetric Theory</a>
                <a href="#asymmetric-code" class="nav-btn">Asymmetric Code</a>
                <a href="#asymmetric-pros-cons" class="nav-btn">Asym. Pros/Cons</a>
                <a href="#web3-use-cases" class="nav-btn">Web3 Use Cases</a>
                <a href="#exercise-quiz" class="nav-btn">Exercise + Quiz</a>
                <a href="#summary" class="nav-btn">Summary</a>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="main-container">
        <!-- Lesson Introduction -->
        <h1 id="intro">🔐 Symmetric vs Asymmetric Cryptography</h1>
        
        <p>Welcome to the foundational lesson of Web3 Odyssey! In this comprehensive exploration, we'll dive deep into the two fundamental approaches to cryptography that power the entire Web3 ecosystem. Understanding the difference between symmetric and asymmetric cryptography is crucial for anyone serious about blockchain development, smart contract security, and decentralized applications.</p>

        <div class="info-tags">
            <span class="info-tag">Intermediate → Advanced</span>
            <span class="info-tag">Node.js Examples</span>
            <span class="info-tag">Approx. 45-60 min</span>
        </div>

        <blockquote>
            "In Web3, keys are identity and signatures are programmable truth. Choose primitives that scale cryptographic trust—not just throughput." — MOKSHA Innovators Guild
        </blockquote>

        <h2>🎯 Learning Objectives</h2>
        <p>By the end of this lesson, you will be able to:</p>
        <ul>
            <li>Understand the fundamental differences between symmetric and asymmetric cryptography</li>
            <li>Implement both encryption methods using Node.js with production-ready code</li>
            <li>Analyze real-world Web3 use cases for each approach</li>
            <li>Evaluate security trade-offs and performance considerations</li>
            <li>Apply cryptographic principles to smart contract development</li>
            <li>Build secure communication systems using hybrid cryptography</li>
        </ul>

        <!-- Slide 1: Introduction to Cryptography -->
        <h2 id="symmetric-theory">📚 Slide 1: The Foundation of Digital Security</h2>
        <img src="./img1.png" alt="Cryptography Foundation" class="slide-image">
        
        <p>Cryptography is the science of secure communication in the presence of adversaries. It's the mathematical foundation that enables trust in the digital world. In Web3, cryptography is not just a tool—it's the very fabric that holds the decentralized ecosystem together.</p>

        <p>At its core, cryptography solves three fundamental problems:</p>
        <ol>
            <li><strong>Confidentiality:</strong> Ensuring that only authorized parties can read the information</li>
            <li><strong>Integrity:</strong> Guaranteeing that the information hasn't been tampered with</li>
            <li><strong>Authentication:</strong> Verifying the identity of the parties involved</li>
        </ol>

        <p>In the context of Web3, these principles are applied to create secure digital wallets, verify smart contract interactions, and establish trust in decentralized networks without relying on central authorities.</p>

        <!-- Slide 2: Symmetric Encryption Theory -->
        <h2>🔐 Slide 2: Symmetric Encryption - The Shared Secret</h2>
        <img src="./img2.png" alt="Symmetric Encryption" class="slide-image">
        
        <p>Symmetric encryption, also known as secret-key encryption, uses the same key for both encryption and decryption. This approach is like having a single key that both locks and unlocks a treasure chest. The key must be kept secret and shared securely between the communicating parties.</p>

        <p>The mathematical foundation of symmetric encryption relies on complex algorithms that transform plaintext into ciphertext using the secret key. Popular symmetric encryption algorithms include:</p>

        <ul>
            <li><strong>AES (Advanced Encryption Standard):</strong> The gold standard for symmetric encryption, supporting key sizes of 128, 192, and 256 bits</li>
            <li><strong>ChaCha20:</strong> A modern stream cipher designed for high performance and security</li>
            <li><strong>3DES (Triple Data Encryption Standard):</strong> A legacy algorithm that applies DES three times for enhanced security</li>
        </ul>

        <p>The strength of symmetric encryption lies in its simplicity and speed. Since the same key is used for both operations, the computational overhead is minimal, making it ideal for encrypting large amounts of data efficiently.</p>

        <!-- Slide 3: Symmetric Encryption Code Example -->
        <h2 id="symmetric-code">💻 Slide 3: Implementing Symmetric Encryption in Node.js</h2>
        <img src="./img3.png" alt="Symmetric Code Example" class="slide-image">
        
        <p>Let's implement a comprehensive symmetric encryption system using Node.js. This example demonstrates multiple algorithms, proper key management, and security best practices.</p>

        <pre><code>const crypto = require('crypto');

class SymmetricEncryption {
    constructor() {
        this.algorithms = {
            aes256gcm: 'aes-256-gcm',
            aes256cbc: 'aes-256-cbc',
            chacha20: 'chacha20-poly1305'
        };
        this.keyLength = 32; // 256 bits
        this.ivLength = 16;  // 128 bits
        this.tagLength = 16; // 128 bits
    }

    // Generate cryptographically secure random key
    generateKey(algorithm = 'aes256gcm') {
        return crypto.randomBytes(this.keyLength);
    }

    // Generate random IV (Initialization Vector)
    generateIV() {
        return crypto.randomBytes(this.ivLength);
    }

    // Encrypt data using AES-256-GCM (Authenticated Encryption)
    encryptAESGCM(plaintext, key, additionalData = '') {
        const iv = this.generateIV();
        const cipher = crypto.createCipher(this.algorithms.aes256gcm, key);
        
        if (additionalData) {
            cipher.setAAD(Buffer.from(additionalData, 'utf8'));
        }
        
        let encrypted = cipher.update(plaintext, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        const tag = cipher.getAuthTag();
        
        return {
            algorithm: this.algorithms.aes256gcm,
            encrypted: encrypted,
            iv: iv.toString('hex'),
            tag: tag.toString('hex'),
            additionalData: additionalData
        };
    }

    // Decrypt data using AES-256-GCM
    decryptAESGCM(encryptedData, key) {
        const decipher = crypto.createDecipher(this.algorithms.aes256gcm, key);
        
        if (encryptedData.additionalData) {
            decipher.setAAD(Buffer.from(encryptedData.additionalData, 'utf8'));
        }
        
        decipher.setAuthTag(Buffer.from(encryptedData.tag, 'hex'));
        
        let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }

    // Encrypt data using AES-256-CBC (Legacy support)
    encryptAESCBC(plaintext, key) {
        const iv = this.generateIV();
        const cipher = crypto.createCipher(this.algorithms.aes256cbc, key);
        
        let encrypted = cipher.update(plaintext, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        return {
            algorithm: this.algorithms.aes256cbc,
            encrypted: encrypted,
            iv: iv.toString('hex')
        };
    }

    // Decrypt data using AES-256-CBC
    decryptAESCBC(encryptedData, key) {
        const decipher = crypto.createDecipher(this.algorithms.aes256cbc, key);
        
        let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }

    // Encrypt data using ChaCha20-Poly1305 (Modern stream cipher)
    encryptChaCha20(plaintext, key) {
        const iv = crypto.randomBytes(12); // ChaCha20 uses 12-byte nonce
        const cipher = crypto.createCipher(this.algorithms.chacha20, key);
        
        let encrypted = cipher.update(plaintext, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        const tag = cipher.getAuthTag();
        
        return {
            algorithm: this.algorithms.chacha20,
            encrypted: encrypted,
            nonce: iv.toString('hex'),
            tag: tag.toString('hex')
        };
    }

    // Decrypt data using ChaCha20-Poly1305
    decryptChaCha20(encryptedData, key) {
        const decipher = crypto.createDecipher(this.algorithms.chacha20, key);
        decipher.setAuthTag(Buffer.from(encryptedData.tag, 'hex'));
        
        let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }

    // Key derivation using PBKDF2 (Password-Based Key Derivation)
    deriveKeyFromPassword(password, salt, iterations = 100000) {
        return crypto.pbkdf2Sync(password, salt, iterations, this.keyLength, 'sha256');
    }

    // Secure key storage (encrypt key with master key)
    encryptKey(keyToEncrypt, masterKey) {
        return this.encryptAESGCM(keyToEncrypt.toString('hex'), masterKey, 'key-encryption');
    }

    // Secure key retrieval
    decryptKey(encryptedKey, masterKey) {
        const decrypted = this.decryptAESGCM(encryptedKey, masterKey);
        return Buffer.from(decrypted, 'hex');
    }
}

// Advanced usage example with multiple algorithms
async function demonstrateSymmetricEncryption() {
    const crypto = new SymmetricEncryption();
    
    // Generate keys
    const aesKey = crypto.generateKey('aes256gcm');
    const chachaKey = crypto.generateKey('chacha20');
    const masterKey = crypto.generateKey('aes256gcm');
    
    const messages = [
        "Hello, Web3 World!",
        "This is a secure message for blockchain applications.",
        "Cryptography is the foundation of trust in decentralized systems."
    ];
    
    console.log("=== Symmetric Encryption Demonstration ===\n");
    
    // Test AES-256-GCM
    console.log("1. AES-256-GCM (Authenticated Encryption):");
    for (let i = 0; i < messages.length; i++) {
        const encrypted = crypto.encryptAESGCM(messages[i], aesKey, `message-${i}`);
        console.log(`   Message ${i + 1}: ${messages[i]}`);
        console.log(`   Encrypted: ${encrypted.encrypted.substring(0, 32)}...`);
        
        const decrypted = crypto.decryptAESGCM(encrypted, aesKey);
        console.log(`   Decrypted: ${decrypted}`);
        console.log(`   Integrity: ${decrypted === messages[i] ? '✓ Verified' : '✗ Failed'}\n`);
    }
    
    // Test ChaCha20-Poly1305
    console.log("2. ChaCha20-Poly1305 (Modern Stream Cipher):");
    const chachaEncrypted = crypto.encryptChaCha20(messages[0], chachaKey);
    console.log(`   Original: ${messages[0]}`);
    console.log(`   Encrypted: ${chachaEncrypted.encrypted.substring(0, 32)}...`);
    
    const chachaDecrypted = crypto.decryptChaCha20(chachaEncrypted, chachaKey);
    console.log(`   Decrypted: ${chachaDecrypted}`);
    console.log(`   Integrity: ${chachaDecrypted === messages[0] ? '✓ Verified' : '✗ Failed'}\n`);
    
    // Test key derivation
    console.log("3. Key Derivation from Password:");
    const password = "MySecurePassword123!";
    const salt = crypto.randomBytes(16);
    const derivedKey = crypto.deriveKeyFromPassword(password, salt);
    console.log(`   Password: ${password}`);
    console.log(`   Derived Key: ${derivedKey.toString('hex').substring(0, 32)}...\n`);
    
    // Test secure key storage
    console.log("4. Secure Key Storage:");
    const encryptedKey = crypto.encryptKey(aesKey, masterKey);
    console.log(`   Original Key: ${aesKey.toString('hex').substring(0, 32)}...`);
    console.log(`   Encrypted Key: ${encryptedKey.encrypted.substring(0, 32)}...`);
    
    const retrievedKey = crypto.decryptKey(encryptedKey, masterKey);
    console.log(`   Retrieved Key: ${retrievedKey.toString('hex').substring(0, 32)}...`);
    console.log(`   Key Integrity: ${aesKey.equals(retrievedKey) ? '✓ Verified' : '✗ Failed'}\n`);
}

// Performance benchmarking
function benchmarkAlgorithms() {
    const crypto = new SymmetricEncryption();
    const testData = "A".repeat(1000000); // 1MB of data
    const iterations = 100;
    
    console.log("=== Performance Benchmark ===\n");
    
    // Benchmark AES-256-GCM
    const aesKey = crypto.generateKey();
    const aesStart = Date.now();
    for (let i = 0; i < iterations; i++) {
        const encrypted = crypto.encryptAESGCM(testData, aesKey);
        crypto.decryptAESGCM(encrypted, aesKey);
    }
    const aesTime = Date.now() - aesStart;
    
    // Benchmark ChaCha20
    const chachaKey = crypto.generateKey();
    const chachaStart = Date.now();
    for (let i = 0; i < iterations; i++) {
        const encrypted = crypto.encryptChaCha20(testData, chachaKey);
        crypto.decryptChaCha20(encrypted, chachaKey);
    }
    const chachaTime = Date.now() - chachaStart;
    
    console.log(`AES-256-GCM: ${aesTime}ms for ${iterations} iterations`);
    console.log(`ChaCha20-Poly1305: ${chachaTime}ms for ${iterations} iterations`);
    console.log(`Performance ratio: ${(aesTime / chachaTime).toFixed(2)}x\n`);
}

// Run demonstrations
demonstrateSymmetricEncryption().then(() => {
    benchmarkAlgorithms();
}).catch(console.error);</code></pre>

        <p>This comprehensive implementation includes multiple algorithms, proper key management, performance benchmarking, and security best practices. The code demonstrates authenticated encryption, key derivation, and secure key storage techniques essential for Web3 applications.</p>

        <!-- Slide 4: Symmetric Encryption Pros & Cons -->
        <h2 id="symmetric-pros-cons">⚖️ Slide 4: Symmetric Encryption Analysis</h2>
        <img src="./img4.png" alt="Symmetric Analysis" class="slide-image">
        
        <table>
            <thead>
                <tr>
                    <th>Advantages</th>
                    <th>Disadvantages</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>⚡ High performance and speed</td>
                    <td>🔑 Key distribution problem</td>
                </tr>
                <tr>
                    <td>🔒 Strong security with proper key management</td>
                    <td>👥 Requires secure key exchange</td>
                </tr>
                <tr>
                    <td>💾 Efficient for large data volumes</td>
                    <td>🔐 Key management complexity</td>
                </tr>
                <tr>
                    <td>🔄 Simple implementation</td>
                    <td>❌ No built-in authentication</td>
                </tr>
                <tr>
                    <td>🎯 Low computational overhead</td>
                    <td>🔍 Vulnerable to key compromise</td>
                </tr>
            </tbody>
        </table>

        <p>The key distribution problem is the Achilles' heel of symmetric encryption. How do you securely share the secret key with someone you've never met? This fundamental limitation led to the development of asymmetric cryptography.</p>

        <!-- Quiz 1 -->
        <div class="quiz-section">
            <h3>🧠 Quick Quiz 1: Symmetric Encryption</h3>
            <p class="quiz-question">Which of the following is the primary challenge with symmetric encryption?</p>
            <ul class="quiz-options">
                <li>A) Computational complexity</li>
                <li>B) Key distribution and management</li>
                <li>C) Encryption speed</li>
                <li>D) Algorithm strength</li>
            </ul>
            <p><strong>Answer:</strong> B) Key distribution and management. The main challenge is securely sharing the secret key between parties without it being intercepted.</p>
        </div>

        <!-- Slide 5: Asymmetric Encryption Theory -->
        <h2 id="asymmetric-theory">🔐 Slide 5: Asymmetric Encryption - The Key Pair Revolution</h2>
        <img src="./img5.png" alt="Asymmetric Encryption" class="slide-image">
        
        <p>Asymmetric encryption, also known as public-key cryptography, uses a pair of mathematically related keys: a public key for encryption and a private key for decryption. This revolutionary approach solves the key distribution problem that plagued symmetric encryption.</p>

        <p>The mathematical foundation of asymmetric encryption is based on complex mathematical problems that are easy to solve in one direction but computationally infeasible to reverse. The most common approaches are:</p>

        <ul>
            <li><strong>RSA (Rivest-Shamir-Adleman):</strong> Based on the difficulty of factoring large prime numbers</li>
            <li><strong>ECC (Elliptic Curve Cryptography):</strong> Based on the discrete logarithm problem in elliptic curve groups</li>
            <li><strong>ElGamal:</strong> Based on the Diffie-Hellman key exchange protocol</li>
        </ul>

        <p>In Web3, ECC is particularly important because it provides the same security level as RSA with much smaller key sizes, making it ideal for blockchain applications where efficiency is crucial.</p>

        <!-- Slide 6: Asymmetric Encryption Code Example -->
        <h2 id="asymmetric-code">💻 Slide 6: Implementing Asymmetric Encryption in Node.js</h2>
        <img src="./img6.png" alt="Asymmetric Code Example" class="slide-image">
        
        <p>Let's implement a comprehensive asymmetric encryption system using Node.js. This example covers RSA, ECC, digital signatures, and key management for Web3 applications.</p>

        <pre><code>const crypto = require('crypto');
const secp256k1 = require('secp256k1'); // For ECC operations

class AsymmetricEncryption {
    constructor() {
        this.rsaKeySize = 2048;
        this.eccCurve = 'secp256k1'; // Bitcoin/Ethereum curve
        this.hashAlgorithm = 'sha256';
        this.encryptionScheme = 'oaep';
    }

    // Generate RSA key pair
    generateRSAKeyPair() {
        return new Promise((resolve, reject) => {
            crypto.generateKeyPair('rsa', {
                modulusLength: this.rsaKeySize,
                publicKeyEncoding: {
                    type: 'spki',
                    format: 'pem'
                },
                privateKeyEncoding: {
                    type: 'pkcs8',
                    format: 'pem'
                }
            }, (err, publicKey, privateKey) => {
                if (err) reject(err);
                else resolve({ publicKey, privateKey });
            });
        });
    }

    // Generate ECC key pair (secp256k1 - Bitcoin/Ethereum compatible)
    generateECCKeyPair() {
        let privateKey;
        do {
            privateKey = crypto.randomBytes(32);
        } while (!secp256k1.privateKeyVerify(privateKey));
        
        const publicKey = secp256k1.publicKeyCreate(privateKey);
        
        return {
            privateKey: privateKey.toString('hex'),
            publicKey: publicKey.toString('hex')
        };
    }

    // Encrypt data using RSA public key
    encryptRSA(plaintext, publicKey) {
        const buffer = Buffer.from(plaintext, 'utf8');
        const encrypted = crypto.publicEncrypt({
            key: publicKey,
            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
            oaepHash: this.hashAlgorithm
        }, buffer);
        
        return encrypted.toString('base64');
    }

    // Decrypt data using RSA private key
    decryptRSA(encryptedData, privateKey) {
        const buffer = Buffer.from(encryptedData, 'base64');
        const decrypted = crypto.privateDecrypt({
            key: privateKey,
            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
            oaepHash: this.hashAlgorithm
        }, buffer);
        
        return decrypted.toString('utf8');
    }

    // Encrypt data using ECC (ECDH + AES)
    encryptECC(plaintext, recipientPublicKey, senderPrivateKey) {
        // Generate ephemeral key pair for this encryption
        const ephemeralKeyPair = this.generateECCKeyPair();
        
        // Perform ECDH key exchange
        const sharedSecret = secp256k1.ecdh(
            Buffer.from(recipientPublicKey, 'hex'),
            Buffer.from(ephemeralKeyPair.privateKey, 'hex')
        );
        
        // Use shared secret to derive AES key
        const aesKey = crypto.createHash('sha256').update(sharedSecret).digest();
        
        // Encrypt data with AES
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipher('aes-256-gcm', aesKey);
        cipher.setAAD(Buffer.from('ecc-encryption', 'utf8'));
        
        let encrypted = cipher.update(plaintext, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        const tag = cipher.getAuthTag();
        
        return {
            algorithm: 'ecc-aes-256-gcm',
            ephemeralPublicKey: ephemeralKeyPair.publicKey,
            encrypted: encrypted,
            iv: iv.toString('hex'),
            tag: tag.toString('hex')
        };
    }

    // Decrypt data using ECC
    decryptECC(encryptedData, recipientPrivateKey) {
        // Perform ECDH key exchange with ephemeral public key
        const sharedSecret = secp256k1.ecdh(
            Buffer.from(encryptedData.ephemeralPublicKey, 'hex'),
            Buffer.from(recipientPrivateKey, 'hex')
        );
        
        // Derive AES key
        const aesKey = crypto.createHash('sha256').update(sharedSecret).digest();
        
        // Decrypt with AES
        const decipher = crypto.createDecipher('aes-256-gcm', aesKey);
        decipher.setAAD(Buffer.from('ecc-encryption', 'utf8'));
        decipher.setAuthTag(Buffer.from(encryptedData.tag, 'hex'));
        
        let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
    }

    // Create digital signature using RSA
    signRSA(data, privateKey) {
        const sign = crypto.createSign('SHA256');
        sign.update(data);
        sign.end();
        return sign.sign(privateKey, 'base64');
    }

    // Verify digital signature using RSA
    verifyRSA(data, signature, publicKey) {
        const verify = crypto.createVerify('SHA256');
        verify.update(data);
        verify.end();
        return verify.verify(publicKey, signature, 'base64');
    }

    // Create digital signature using ECC (secp256k1)
    signECC(data, privateKey) {
        const messageHash = crypto.createHash('sha256').update(data).digest();
        const signature = secp256k1.sign(messageHash, Buffer.from(privateKey, 'hex'));
        return {
            signature: signature.signature.toString('hex'),
            recovery: signature.recovery
        };
    }

    // Verify digital signature using ECC
    verifyECC(data, signature, publicKey) {
        const messageHash = crypto.createHash('sha256').update(data).digest();
        return secp256k1.verify(messageHash, Buffer.from(signature.signature, 'hex'), Buffer.from(publicKey, 'hex'));
    }

    // Generate Bitcoin/Ethereum compatible address from public key
    generateAddress(publicKey) {
        const hash1 = crypto.createHash('sha256').update(Buffer.from(publicKey, 'hex')).digest();
        const hash2 = crypto.createHash('ripemd160').update(hash1).digest();
        return hash2.toString('hex');
    }

    // Key derivation for hierarchical deterministic wallets (BIP-32)
    deriveChildKey(parentPrivateKey, parentPublicKey, index, chainCode) {
        const data = Buffer.concat([
            Buffer.from(parentPublicKey, 'hex'),
            Buffer.alloc(4),
            Buffer.from(index.toString(16).padStart(8, '0'), 'hex')
        ]);
        
        const hmac = crypto.createHmac('sha512', chainCode);
        hmac.update(data);
        const result = hmac.digest();
        
        const childPrivateKey = (BigInt('0x' + parentPrivateKey) + BigInt('0x' + result.slice(0, 32).toString('hex'))) % BigInt('0x' + 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
        
        return {
            privateKey: childPrivateKey.toString(16).padStart(64, '0'),
            chainCode: result.slice(32).toString('hex')
        };
    }
}

// Advanced usage example with multiple algorithms
async function demonstrateAsymmetricEncryption() {
    const crypto = new AsymmetricEncryption();
    
    console.log("=== Asymmetric Encryption Demonstration ===\n");
    
    // Test RSA
    console.log("1. RSA Encryption and Digital Signatures:");
    const rsaKeys = await crypto.generateRSAKeyPair();
    const rsaMessage = "Hello, Web3 World!";
    
    const rsaEncrypted = crypto.encryptRSA(rsaMessage, rsaKeys.publicKey);
    console.log(`   Original: ${rsaMessage}`);
    console.log(`   Encrypted: ${rsaEncrypted.substring(0, 50)}...`);
    
    const rsaDecrypted = crypto.decryptRSA(rsaEncrypted, rsaKeys.privateKey);
    console.log(`   Decrypted: ${rsaDecrypted}`);
    console.log(`   Integrity: ${rsaDecrypted === rsaMessage ? '✓ Verified' : '✗ Failed'}`);
    
    const rsaSignature = crypto.signRSA(rsaMessage, rsaKeys.privateKey);
    const rsaVerified = crypto.verifyRSA(rsaMessage, rsaSignature, rsaKeys.publicKey);
    console.log(`   Signature: ${rsaSignature.substring(0, 50)}...`);
    console.log(`   Verified: ${rsaVerified ? '✓ Valid' : '✗ Invalid'}\n`);
    
    // Test ECC
    console.log("2. ECC Encryption and Digital Signatures:");
    const aliceKeys = crypto.generateECCKeyPair();
    const bobKeys = crypto.generateECCKeyPair();
    const eccMessage = "Secure ECC communication";
    
    const eccEncrypted = crypto.encryptECC(eccMessage, bobKeys.publicKey, aliceKeys.privateKey);
    console.log(`   Original: ${eccMessage}`);
    console.log(`   Encrypted: ${eccEncrypted.encrypted.substring(0, 32)}...`);
    
    const eccDecrypted = crypto.decryptECC(eccEncrypted, bobKeys.privateKey);
    console.log(`   Decrypted: ${eccDecrypted}`);
    console.log(`   Integrity: ${eccDecrypted === eccMessage ? '✓ Verified' : '✗ Failed'}`);
    
    const eccSignature = crypto.signECC(eccMessage, aliceKeys.privateKey);
    const eccVerified = crypto.verifyECC(eccMessage, eccSignature, aliceKeys.publicKey);
    console.log(`   Signature: ${eccSignature.signature.substring(0, 32)}...`);
    console.log(`   Verified: ${eccVerified ? '✓ Valid' : '✗ Invalid'}\n`);
    
    // Test address generation
    console.log("3. Bitcoin/Ethereum Address Generation:");
    const walletKeys = crypto.generateECCKeyPair();
    const address = crypto.generateAddress(walletKeys.publicKey);
    console.log(`   Public Key: ${walletKeys.publicKey.substring(0, 32)}...`);
    console.log(`   Address: ${address}\n`);
    
    // Test key derivation
    console.log("4. Hierarchical Deterministic Key Derivation:");
    const masterKeys = crypto.generateECCKeyPair();
    const chainCode = crypto.randomBytes(32).toString('hex');
    
    for (let i = 0; i < 3; i++) {
        const childKeys = crypto.deriveChildKey(
            masterKeys.privateKey,
            masterKeys.publicKey,
            i,
            chainCode
        );
        console.log(`   Child ${i}: ${childKeys.privateKey.substring(0, 32)}...`);
    }
    console.log();
}

// Performance comparison
function benchmarkAsymmetricAlgorithms() {
    const crypto = new AsymmetricEncryption();
    const testData = "Test message for asymmetric encryption";
    const iterations = 100;
    
    console.log("=== Asymmetric Algorithm Performance ===\n");
    
    // Benchmark RSA
    crypto.generateRSAKeyPair().then(rsaKeys => {
        const rsaStart = Date.now();
        for (let i = 0; i < iterations; i++) {
            const encrypted = crypto.encryptRSA(testData, rsaKeys.publicKey);
            crypto.decryptRSA(encrypted, rsaKeys.privateKey);
        }
        const rsaTime = Date.now() - rsaStart;
        
        // Benchmark ECC
        const eccKeys = crypto.generateECCKeyPair();
        const eccStart = Date.now();
        for (let i = 0; i < iterations; i++) {
            const encrypted = crypto.encryptECC
