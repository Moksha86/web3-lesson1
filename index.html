 Title 
<title>Web3 Odyssey — Module 1: Lesson 1.1 — Symmetric vs Asymmetric Cryptography | MOKSHA Innovators Guild</title>

 Favicon & Required Local Assets 
 The following files must exist in the repository root:
     - favicon.png
     - logo.png
     - img1.png ... img10.png

<link rel="icon" href="./favicon.png" type="image/png" />

 Google Fonts (Allowed External) 
<link
  href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700;900&family=Roboto+Slab:wght@700;800&family=Roboto+Mono:wght@400;500;700&family=Fira+Mono:wght@400;500;700&display=swap"
  rel="stylesheet"
/>

 Styles (All Inline as Required) 
<style>
  :root {
    --bg-start: #0a0f2a;
    --bg-end: #0b0f2f;
    --panel-start: #0e1438;
    --panel-end: #0b1032;
    --ink: #dbe7ff;
    --muted: #aab4d4;
    --neon-cyan: #00e5ff;
    --neon-violet: #9b5de5;
    --accent-blue: #4cc9f0;
    --success: #20e3b2;
    --warning: #ffcb6b;
    --danger: #ff6b6b;
    --border: rgba(255, 255, 255, 0.12);
    --shadow-neon: 0 0 0.5rem rgba(0, 229, 255, 0.15), 0 0 2.5rem rgba(155, 93, 229, 0.18);
    --shadow-panel: 0 10px 35px rgba(0, 0, 0, 0.55), 0 0 50px rgba(0, 229, 255, 0.05);
    --header-bg: rgba(6, 10, 28, 0.9);
    --header-border: rgba(255, 255, 255, 0.08);
    --code-bg: #0a1128;
    --code-border: rgba(76, 201, 240, 0.25);
    --blockquote-bg: rgba(0, 229, 255, 0.08);
    --blockquote-border: rgba(0, 229, 255, 0.8);
    --table-head-bg: rgba(155, 93, 229, 0.15);
    --table-row-alt: rgba(255, 255, 255, 0.03);
    --focus: 0 0 0 3px rgba(0, 229, 255, 0.35), 0 0 0 1px rgba(0, 229, 255, 0.65) inset;
  }

  /* Base */
  * {
    box-sizing: border-box;
  }
  html {
    scroll-behavior: smooth;
  }
  body {
    margin: 0;
    color: var(--ink);
    background: radial-gradient(1200px 800px at 10% -10%, #0c1542 0%, transparent 60%), linear-gradient(180deg, var(--bg-start) 0%, var(--bg-end) 100%);
    font-family: "Roboto", system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
    line-height: 1.65;
    min-height: 100vh;
  }
  a {
    color: var(--neon-cyan);
    text-decoration: none;
    transition: color 0.2s ease, text-shadow 0.2s ease;
  }
  a:hover, a:focus {
    color: #66f2ff;
    text-shadow: 0 0 10px rgba(0, 229, 255, 0.5);
    outline: none;
  }
  img {
    max-width: 100%;
    height: auto;
    display: block;
  }
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
  }

  /* Header */
  header.site-header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background: linear-gradient(180deg, var(--header-bg) 0%, rgba(6, 10, 28, 0.7) 100%);
    border-bottom: 1px solid var(--header-border);
    backdrop-filter: blur(12px);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
  }
  .header-inner {
    max-width: 1200px;
    margin: 0 auto;
    padding: 18px 24px;
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 18px;
    align-items: center;
  }
  .brand {
    display: inline-flex;
    align-items: center;
    gap: 14px;
  }
  .brand img {
    height: 60px;
    width: auto;
    filter: drop-shadow(0 4px 12px rgba(0, 229, 255, 0.25));
  }
  .brand .title-wrap h1 {
    margin: 0;
    font-family: "Roboto Slab", Georgia, serif;
    font-weight: 800;
    font-size: clamp(1.2rem, 1.7vw, 1.8rem);
    letter-spacing: 0.6px;
    color: #e7eeff;
    text-shadow: 0 0 16px rgba(155, 93, 229, 0.35), 0 0 6px rgba(0, 229, 255, 0.25);
  }
  .brand .title-wrap p {
    margin: 2px 0 0;
    color: var(--muted);
    font-size: clamp(0.85rem, 1.1vw, 1rem);
  }
  nav.toc {
    justify-self: end;
    display: flex;
    gap: 14px;
    flex-wrap: wrap;
  }
  nav.toc a {
    padding: 8px 12px;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid rgba(255, 255, 255, 0.07);
    color: #d8e7ff;
    font-size: 0.9rem;
  }
  nav.toc a:hover {
    background: rgba(0, 229, 255, 0.1);
    border-color: rgba(0, 229, 255, 0.35);
  }

  /* Main container */
  main {
    padding-top: 110px; /* header height + spacing */
    padding-bottom: 80px;
  }
  .container {
    max-width: 1100px;
    margin: 0 auto;
    padding: 28px;
  }
  .panel {
    background: linear-gradient(180deg, var(--panel-start), var(--panel-end));
    border: 1px solid var(--border);
    border-radius: 18px;
    box-shadow: var(--shadow-panel), inset 0 0 20px rgba(155, 93, 229, 0.05);
    padding: clamp(22px, 3.2vw, 38px);
  }

  /* Headings */
  h2.section-title {
    margin-top: 0;
    margin-bottom: 12px;
    font-family: "Roboto Slab", Georgia, serif;
    font-weight: 800;
    font-size: clamp(1.6rem, 2.4vw, 2.1rem);
    letter-spacing: 0.4px;
    color: #f1f6ff;
    text-shadow: 0 0 18px rgba(0, 229, 255, 0.25), 0 0 12px rgba(155, 93, 229, 0.25);
  }
  h3.sub-title {
    margin-top: 16px;
    margin-bottom: 8px;
    font-weight: 700;
    font-size: clamp(1.1rem, 1.6vw, 1.25rem);
    color: #e6edff;
  }

  /* Figure / images */
  figure.slide-figure {
    margin: 18px auto 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }
  .slide-figure img {
    width: min(80%, 860px);
    border-radius: 14px;
    border: 1px solid rgba(0, 229, 255, 0.25);
    box-shadow: 0 6px 28px rgba(0, 229, 255, 0.08), 0 12px 48px rgba(155, 93, 229, 0.12);
  }
  .slide-figure figcaption {
    color: var(--muted);
    font-size: 0.92rem;
  }

  /* Code blocks */
  pre {
    background: linear-gradient(180deg, #070c1d, var(--code-bg));
    border: 1px solid var(--code-border);
    border-radius: 14px;
    padding: 16px 18px;
    overflow: auto;
    color: #e8f3ff;
    box-shadow: inset 0 0 24px rgba(0, 229, 255, 0.05);
  }
  code {
    font-family: "Roboto Mono", "Fira Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    font-size: 0.92rem;
  }
  /* Simple CSS-only highlighting accents */
  code .k { color: #82aaff; }    /* keyword */
  code .fn { color: #c3e88d; }   /* function */
  code .str { color: #c792ea; }  /* string */
  code .num { color: #f78c6c; }  /* number */
  code .com { color: #697799; }  /* comment */

  /* Tables */
  .table-wrap {
    overflow-x: auto;
    border-radius: 14px;
    border: 1px solid rgba(0, 229, 255, 0.2);
    box-shadow: inset 0 0 0 1px rgba(155, 93, 229, 0.15);
  }
  table {
    width: 100%;
    border-collapse: collapse;
    min-width: 680px;
  }
  thead th {
    background: var(--table-head-bg);
    color: #e9f0ff;
    text-align: left;
    padding: 12px 14px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.12);
    font-weight: 700;
  }
  tbody td {
    padding: 12px 14px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    color: #dbe4ff;
  }
  tbody tr:nth-child(even) td {
    background: var(--table-row-alt);
  }

  /* Blockquote */
  blockquote {
    margin: 18px 0;
    padding: 14px 16px;
    border-left: 4px solid var(--blockquote-border);
    background: var(--blockquote-bg);
    border-radius: 12px;
    color: #d9eeff;
  }

  /* Quiz (details/summary) */
  details.quiz {
    margin: 12px 0 0;
    padding: 0;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(0, 229, 255, 0.2);
  }
  details.quiz > summary {
    cursor: pointer;
    list-style: none;
    padding: 12px 14px;
    font-weight: 600;
    color: #e8f6ff;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  details.quiz > summary::before {
    content: "▸";
    color: var(--neon-cyan);
    font-weight: 900;
    display: inline-block;
    transform: translateY(-1px);
  }
  details.quiz[open] > summary::before {
    content: "▾";
  }
  details.quiz .answer {
    padding: 0 14px 14px;
    color: #cfe6ff;
  }

  /* Slide sections */
  section.slide {
    margin-top: 34px;
    scroll-margin-top: 92px;
  }
  .meta-row {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin: 10px 0 6px;
  }
  .badge {
    border-radius: 999px;
    padding: 6px 10px;
    font-size: 0.78rem;
    letter-spacing: 0.3px;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: rgba(255, 255, 255, 0.05);
    color: #dbe7ff;
  }
  .badge.cyan {
    border-color: rgba(0, 229, 255, 0.35);
    background: rgba(0, 229, 255, 0.08);
    color: #c8f7ff;
  }
  .badge.violet {
    border-color: rgba(155, 93, 229, 0.35);
    background: rgba(155, 93, 229, 0.08);
    color: #ecd6ff;
  }

  /* Footer */
  footer.site-footer {
    padding: 30px 18px 50px;
    border-top: 1px solid rgba(255, 255, 255, 0.08);
    background: linear-gradient(180deg, rgba(6, 10, 28, 0.3) 0%, rgba(6, 10, 28, 0.6) 100%);
    text-align: center;
    color: #b9c6e6;
    font-size: 0.95rem;
  }

  /* Responsive */
  @media (max-width: 900px) {
    .header-inner {
      grid-template-columns: 1fr;
      gap: 12px;
    }
    nav.toc {
      justify-self: start;
      overflow-x: auto;
      padding-bottom: 6px;
      scrollbar-width: thin;
    }
    .slide-figure img {
      width: 92%;
    }
  }
  @media (max-width: 560px) {
    .brand .title-wrap h1 {
      font-size: 1.2rem;
    }
    .brand img {
      height: 48px;
    }
    nav.toc a {
      font-size: 0.86rem;
      padding: 7px 10px;
    }
    .container {
      padding: 16px;
    }
    .panel {
      padding: 18px;
    }
  }

  /* Focus styles for accessibility */
  a:focus-visible, summary:focus-visible, button:focus-visible {
    outline: none;
    box-shadow: var(--focus);
    border-radius: 10px;
  }

  /* Custom scrollbar */
  ::-webkit-scrollbar {
    height: 10px;
    width: 10px;
  }
  ::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, rgba(0, 229, 255, 0.55), rgba(155, 93, 229, 0.55));
    border-radius: 10px;
  }
  ::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.04);
  }
</style>
 Header 
<header class="site-header" role="banner" aria-label="Course header">
  <div class="header-inner">
    <div class="brand">
      <img src="./logo.png" alt="MOKSHA Innovators Guild logo" />
      <div class="title-wrap">
        <h1>Web3 Odyssey</h1>
        <p>Module 1: Foundations | Lesson 1.1 — Symmetric vs Asymmetric Cryptography</p>
      </div>
    </div>
    <nav class="toc" aria-label="In-page navigation">
      <a href="#slide-1">Intro</a>
      <a href="#slide-2">Symmetric Theory</a>
      <a href="#slide-3">Symmetric Code</a>
      <a href="#slide-4">Symmetric Pros/Cons</a>
      <a href="#slide-5">Asymmetric Theory</a>
      <a href="#slide-6">Asymmetric Code</a>
      <a href="#slide-7">Asym. Pros/Cons</a>
      <a href="#slide-8">Web3 Use Cases</a>
      <a href="#slide-9">Exercise + Quiz</a>
      <a href="#slide-10">Summary</a>
    </nav>
  </div>
</header>

 Main 
<main id="content" role="main">
  <div class="container">
     Overview Panel 
    <section class="panel" aria-labelledby="lesson-intro">
      <h2 id="lesson-intro" class="section-title">Lesson Introduction & Objectives</h2>
      <p>
        Cryptography is the security backbone of Web3. Keys, signatures, and ciphers dictate how wallets authenticate, how nodes validate, and how smart contracts enforce trustless rules. In this lesson, you will internalize the difference between symmetric and asymmetric cryptography, understand when to use each, and see practical Node.js examples that mirror real Web3 workflows. We will reason about performance, threat models, and developer ergonomics while maintaining an academic approach and a futuristic, systems-level mindset consistent with the MOKSHA Innovators Guild philosophy.
      </p>
      <div class="meta-row" aria-label="Lesson metadata">
        <span class="badge cyan">Intermediate → Advanced</span>
        <span class="badge violet">Node.js Examples</span>
        <span class="badge">Approx. 45–60 min</span>
      </div>

      <blockquote>
        In Web3, your cryptography choices determine not only confidentiality but also composability, usability, and consensus-level integrity. Treat keys as the source of identity. Treat signatures as programmable truth.
      </blockquote>

      <div class="table-wrap" role="region" aria-label="Lesson Objectives">
        <table>
          <thead>
            <tr>
              <th>Objective</th>
              <th>Details</th>
              <th>Outcome</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Distinguish symmetric vs asymmetric</td>
              <td>Concepts, performance, and threat models</td>
              <td>Know when to use which family</td>
            </tr>
            <tr>
              <td>Implement symmetric encryption</td>
              <td>AES-256-GCM with Node.js</td>
              <td>Confidentiality with authenticity</td>
            </tr>
            <tr>
              <td>Implement asymmetric operations</td>
              <td>RSA-OAEP and ECDSA (secp256k1)</td>
              <td>Key exchange, signatures, and identity</td>
            </tr>
            <tr>
              <td>Apply to Web3</td>
              <td>Wallets, smart contracts, off-chain signing</td>
              <td>Secure end-to-end flows</td>
            </tr>
          </tbody>
        </table>
      </div>

      <details class="quiz" aria-label="Intro Quiz">
        <summary>Quick Check: Which cryptographic family underpins wallet addresses and signatures on Ethereum?</summary>
        <div class="answer">
          Asymmetric cryptography (Elliptic Curve Digital Signature Algorithm, ECDSA on secp256k1). Public keys derive addresses; private keys produce signatures verified by anyone.
        </div>
      </details>
    </section>

     Slides 
     Slide 1 
    <section id="slide-1" class="slide panel" aria-labelledby="slide-1-title">
      <h2 id="slide-1-title" class="section-title">Slide 1 — Symmetric vs Asymmetric: The Big Picture</h2>
      <figure class="slide-figure">
        <img src="./img1.png" alt="High-level diagram contrasting symmetric and asymmetric cryptography flows" />
        <figcaption>At a glance: shared secret vs public/private key pairs.</figcaption>
      </figure>
      <p>
        Symmetric and asymmetric cryptography are complementary tools. In symmetric cryptography, one key performs both encryption and decryption. This model is fast and efficient, making it ideal for bulk data encryption, streaming, and performance-sensitive workloads. The principal risk is key distribution: if you and your counterparty need to communicate securely, both must possess the same secret, and exchanging that secret safely becomes the main challenge. Modern symmetric ciphers like AES (especially AES-GCM) and ChaCha20-Poly1305 also provide integrity via authenticated encryption, ensuring ciphertext tampering is detected.
      </p>
      <p>
        Asymmetric cryptography uses mathematically linked key pairs: a public key (shareable) and a private key (confidential). Common operations include encryption with the recipient&rsquo;s public key (only the holder of the private key can decrypt) and digital signatures where the private key signs and anyone with the public key verifies. Although asymmetric operations are computationally heavier than symmetric ones, they solve the distribution problem and enable decentralized identity, authorization, and key exchanges without a secure channel. In practice, modern systems combine both families: asymmetric methods establish secrets or authenticate parties, while symmetric ciphers handle high-throughput encryption once a shared key exists.
      </p>
      <p>
        Web3 relies heavily on asymmetric cryptography for identity and authorization (wallets and signatures), and on symmetric cryptography for performance-critical confidentiality tasks like encrypting off-chain content-addressed data. Understanding the trade-offs helps you architect systems that are both secure and ergonomic. You&rsquo;ll see how this duality appears in wallet flows (ECDSA), message encryption (AES-GCM), and hybrid protocols where a short asymmetric step negotiates a key followed by symmetric data protection.
      </p>

      <details class="quiz">
        <summary>Mini Quiz: Why combine both families in a single protocol?</summary>
        <div class="answer">
          Asymmetric crypto solves key distribution and identity via signatures, while symmetric crypto delivers high-speed, low-latency encryption for bulk data. The hybrid approach yields secure key establishment plus efficient data protection.
        </div>
      </details>
    </section>

     Slide 2 
    <section id="slide-2" class="slide panel" aria-labelledby="slide-2-title">
      <h2 id="slide-2-title" class="section-title">Slide 2 — Symmetric Encryption Theory (AES, ChaCha20, 3DES)</h2>
      <figure class="slide-figure">
        <img src="./img2.png" alt="Symmetric cipher blocks and stream diagram with keys and nonces" />
        <figcaption>CTR- and GCM-mode counters and nonces drive keystream uniqueness.</figcaption>
      </figure>
      <p>
        Symmetric cryptography uses the same secret key for encryption and decryption. AES (Advanced Encryption Standard) is the de-facto standard. AES operates on 128-bit blocks and supports key sizes of 128, 192, and 256 bits. Security in practice is determined by both algorithm and mode of operation. Authenticated Encryption with Associated Data (AEAD) modes, notably AES-GCM and ChaCha20-Poly1305, provide confidentiality and integrity simultaneously. GCM (Galois/Counter Mode) combines counter-mode encryption with a GHASH-based authentication tag; if the tag fails to verify, the ciphertext is rejected. ChaCha20-Poly1305 is a stream cipher suite excellent for software-only environments and mobile devices, often outperforming AES where hardware acceleration is absent.
      </p>
      <p>
        Historically, 3DES (Triple DES) applied DES three times to increase security, but it is now considered legacy due to smaller blocks, lower performance, and practical limitations. For modern systems, prefer AES-GCM or ChaCha20-Poly1305. The security of symmetric schemes depends on key entropy, nonce/IV uniqueness, and correct implementation. Reusing a nonce with the same key in counter-type modes (GCM/CTR) can catastrophically reveal keystream relationships. AEAD modes protect against active tampering; without authentication, attackers can flip bits in ciphertext to produce controlled changes in plaintext.
      </p>
      <div class="table-wrap" role="region" aria-label="Symmetric Cipher Comparison">
        <table>
          <thead>
            <tr>
              <th>Cipher</th>
              <th>Mode / Suite</th>
              <th>Strengths</th>
              <th>Caveats</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>AES-256-GCM</td>
              <td>AEAD (counter + GHASH)</td>
              <td>Fast with hardware AES-NI; integrated authentication</td>
              <td>Nonce uniqueness required; GHASH implementation must be constant-time</td>
            </tr>
            <tr>
              <td>ChaCha20-Poly1305</td>
              <td>AEAD (stream + MAC)</td>
              <td>Great on mobile/ARM; constant-time; robust without AES-NI</td>
              <td>Key and nonce management still critical; larger per-record overhead vs raw stream</td>
            </tr>
            <tr>
              <td>3DES</td>
              <td>Legacy block cipher</td>
              <td>Historical compatibility</td>
              <td>Slow, small block size (64-bit); avoid in new designs</td>
            </tr>
          </tbody>
        </table>
      </div>
      <details class="quiz">
        <summary>Mini Quiz: Why is nonce reuse dangerous in GCM?</summary>
        <div class="answer">
          Reusing a nonce with the same key in counter-based modes reveals relations between keystream blocks, enabling attackers to infer plaintext differences and sometimes fully recover messages. It also undermines authentication in GCM.
        </div>
      </details>
    </section>

     Slide 3 
    <section id="slide-3" class="slide panel" aria-labelledby="slide-3-title">
      <h2 id="slide-3-title" class="section-title">Slide 3 — Symmetric Encryption Code Example (Node.js, AES-256-GCM)</h2>
      <figure class="slide-figure">
        <img src="./img3.png" alt="Code visualization of AES-GCM encrypt/decrypt flow with IV and tag" />
        <figcaption>Encrypt with a random IV; authenticate with the GCM tag; verify before decrypting.</figcaption>
      </figure>
      <p>
        The Node.js <code>crypto</code> module supports AES-GCM out of the box. The following example implements safe defaults: a 32-byte key for AES-256-GCM, a 12-byte random IV (nonce), and associated data (AAD) support to authenticate context (like headers, addresses, or protocol labels) without encrypting it. The ciphertext, tag, and IV must be preserved to decrypt. Never reuse IVs with the same key; one standard approach is to generate fresh IVs per message using <code>randomBytes</code>.
      </p>
      <pre aria-label="AES-256-GCM Node.js example"><code>
               Slide 4 
    <section id="slide-4" class="slide panel" aria-labelledby="slide-4-title">
      <h2 id="slide-4-title" class="section-title">Slide 4 — Symmetric Pros &amp; Cons</h2>
      <figure class="slide-figure">
        <img src="./img4.png" alt="Speed and throughput graph highlighting symmetric cipher performance" />
        <figcaption>Symmetric ciphers dominate in throughput and energy efficiency.</figcaption>
      </figure>
      <p>
        Symmetric cryptography excels at speed and simplicity. It requires minimal computation per byte, enabling secure streaming and storage even on constrained devices. With hardware acceleration (e.g., AES-NI), throughput can exceed multiple gigabytes per second per core. However, the fatal flaw is key distribution: if an attacker obtains the symmetric key, they can both decrypt and forge authenticated ciphertexts. Consequently, production systems typically pair symmetric ciphers with asymmetric key exchange protocols or public-key infrastructure to bootstrap secrets safely. Secure key rotation policies and careful nonce management reduce systemic risks.
      </p>
      <div class="table-wrap" role="region" aria-label="Symmetric Pros and Cons">
        <table>
          <thead>
            <tr>
              <th>Aspect</th>
              <th>Pros</th>
              <th>Cons</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Performance</td>
              <td>Extremely fast, low latency, low power</td>
              <td>None inherent; speed can mask misuse</td>
            </tr>
            <tr>
              <td>Security</td>
              <td>Strong AEAD modes provide confidentiality + integrity</td>
              <td>Key distribution and storage are single points of failure</td>
            </tr>
            <tr>
              <td>Complexity</td>
              <td>Straightforward APIs (key, IV, tag)</td>
              <td>Nonce reuse risks; key lifecycle management burdens</td>
            </tr>
            <tr>
              <td>Web3 Fit</td>
              <td>Perfect for encrypting off-chain blobs and P2P streams</td>
              <td>Needs asymmetric layer for access control and sharing</td>
            </tr>
          </tbody>
        </table>
      </div>
      <details class="quiz">
        <summary>Mini Quiz: What is the primary operational risk in symmetric systems?</summary>
        <div class="answer">
          Securely distributing and storing the shared key. If compromised, an attacker can decrypt data and create valid ciphertexts (breaks confidentiality and integrity).
        </div>
      </details>
    </section>

     Slide 5 
    <section id="slide-5" class="slide panel" aria-labelledby="slide-5-title">
      <h2 id="slide-5-title" class="section-title">Slide 5 — Asymmetric Encryption Theory (RSA, ECC)</h2>
      <figure class="slide-figure">
        <img src="./img5.png" alt="Public/private key pair conceptual diagram with encryption and signature arrows" />
        <figcaption>Encrypt to a public key; sign with a private key; verify with the corresponding public key.</figcaption>
      </figure>
      <p>
        Asymmetric cryptography relies on a one-way mathematical relationship between a private key and its public key. With RSA, security arises from the difficulty of factoring a large composite modulus <code>n = p × q</code>. A public exponent <code>e</code> and private exponent <code>d</code> satisfy <code>(m^e)^d ≡ m (mod n)</code>. For encryption, a sender computes <code>c = m^e mod n</code> using the recipient’s public key, and the recipient recovers <code>m = c^d mod n</code> with the private key. For signatures, the direction flips: sign with <code>d</code>, verify with <code>e</code>. Modern RSA deployments pair with OAEP padding for encryption and PSS for signatures to resist adaptive attacks.
      </p>
      <p>
        Elliptic Curve Cryptography (ECC) uses the discrete logarithm problem on elliptic curves. A private key is a scalar; the public key is the scalar multiple of a base point on the curve. ECDSA (used by Ethereum&rsquo;s secp256k1) provides compact signatures and strong security at smaller key sizes than RSA. In Web3, wallets hold ECC private keys; addresses derive from public keys via hashing and encoding rules. Asymmetric operations are slower than symmetric ones, but they remove the need to share secrets in advance, enabling decentralized authentication and open verification. Best practice is to use asymmetric cryptography for identity, key exchange, and signatures, while delegating bulk data encryption to symmetric ciphers.
      </p>
      <details class="quiz">
        <summary>Mini Quiz: Why is ECC preferred over RSA in many modern systems?</summary>
        <div class="answer">
          ECC achieves comparable security with much smaller key sizes and signatures, reducing bandwidth, storage, and computation—crucial for mobile and blockchain environments.
        </div>
      </details>
    </section>

     Slide 6 
    <section id="slide-6" class="slide panel" aria-labelledby="slide-6-title">
      <h2 id="slide-6-title" class="section-title">Slide 6 — Asymmetric Code Examples (Node.js, RSA-OAEP &amp; ECDSA)</h2>
      <figure class="slide-figure">
        <img src="./img6.png" alt="Key pair generation and signature verification flow chart" />
        <figcaption>Generate key pairs, encrypt with public, decrypt with private; sign with private, verify with public.</figcaption>
      </figure>
      <p>
        Node.js provides robust primitives for RSA and EC keys. For confidentiality, use RSA with OAEP (SHA-256). For signatures compatible with Web3 mental models, generate an EC key pair with secp256k1 and sign payloads deterministically. Remember: on Ethereum, wallets sign messages and transactions using ECDSA; smart contracts verify signatures by recovering the signer’s public key/address. Below are concise patterns illustrating these operations in Node.js with the built-in <code>crypto</code> module.
      </p>
      <pre aria-label="RSA-OAEP encryption/decryption in Node.js"><code>
                <pre aria-label="ECDSA secp256k1 signature in Node.js"><code>
                          <p>
        Use RSA-OAEP when you need to send a short secret (e.g., a symmetric AES key) to a specific recipient. Use ECDSA when you need non-repudiable statements tied to a public identity. In decentralized applications, a safe pattern is hybrid encryption: generate a random AES key, encrypt your payload with AES-GCM, then encrypt the AES key using the recipient&rsquo;s RSA or ECIES-style scheme; share the small encrypted key alongside the ciphertext.
      </p>
      <details class="quiz">
        <summary>Mini Quiz: What makes RSA-OAEP safer than raw RSA?</summary>
        <div class="answer">
          OAEP is a padding scheme that randomizes inputs and binds a hash function (e.g., SHA-256), preventing deterministic ciphertexts and mitigating chosen-ciphertext attacks against raw RSA.
        </div>
      </details>
    </section>

     Slide 7 
    <section id="slide-7" class="slide panel" aria-labelledby="slide-7-title">
      <h2 id="slide-7-title" class="section-title">Slide 7 — Asymmetric Pros &amp; Cons</h2>
      <figure class="slide-figure">
        <img src="./img7.png" alt="Matrix comparing RSA and ECC in size, speed, and security margins" />
        <figcaption>ECC provides smaller keys and signatures; RSA offers mature tooling and audit history.</figcaption>
      </figure>
      <p>
        Asymmetric cryptography enables open, verifiable identity without prior secret exchange. Public keys can be widely distributed, and signatures can be checked by anyone, an essential property for decentralized consensus. The costs include heavier computation, larger CPU-time for key generation, and more careful implementation to avoid side channels. RSA is ubiquitous and well-studied; ECC is leaner and faster for signature verification with far smaller artifacts—ideal for bandwidth-constrained networks and on-chain verification costs. Algorithm choice should consider ecosystem compatibility, hardware, and security requirements (including post-quantum planning).
      </p>
      <div class="table-wrap" role="region" aria-label="Asymmetric Pros and Cons">
        <table>
          <thead>
            <tr>
              <th>Aspect</th>
              <th>Pros</th>
              <th>Cons</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Identity &amp; Auth</td>
              <td>Public verifiability; no pre-shared secrets</td>
              <td>Key management complexity; revocation challenges</td>
            </tr>
            <tr>
              <td>Performance</td>
              <td>Acceptable for key exchange and signatures</td>
              <td>Slower than symmetric; expensive on-chain if misused</td>
            </tr>
            <tr>
              <td>Artifacts</td>
              <td>ECC: compact keys/signatures</td>
              <td>RSA: larger keys/signatures increase bandwidth</td>
            </tr>
            <tr>
              <td>Web3 Fit</td>
              <td>Core to wallets and permissionless verification</td>
              <td>Use sparingly for data encryption; prefer hybrid designs</td>
            </tr>
          </tbody>
        </table>
      </div>
      <details class="quiz">
        <summary>Mini Quiz: What property makes signatures ideal for decentralized verification?</summary>
        <div class="answer">
          Anyone can verify a signature using only the public key, enabling global, trust-minimized validation without contacting the signer or sharing secrets.
        </div>
      </details>
    </section>

     Slide 8 
    <section id="slide-8" class="slide panel" aria-labelledby="slide-8-title">
      <h2 id="slide-8-title" class="section-title">Slide 8 — Web3 Use Cases: Wallets, Smart Contracts, Signatures</h2>
      <figure class="slide-figure">
        <img src="./img8.png" alt="Web3 signature flow: user signs, dApp verifies, contract recovers address" />
        <figcaption>Sign off-chain, verify on-chain: security and gas efficiency at scale.</figcaption>
      </figure>
      <p>
        Wallets are asymmetric key managers. The user holds a private key; the public key (or its hash) becomes the address. Off-chain messages (EIP-191/712) are signed by the wallet; the dApp verifies locally before sending the signature to a contract when needed. Smart contracts recover the signer&rsquo;s address and apply authorization rules, keeping heavy cryptography off-chain to save gas. For confidentiality, Web3 apps often encrypt data off-chain using symmetric ciphers then gate the decryption key via access control (e.g., group membership, token ownership, or threshold schemes) managed with asymmetric primitives.
      </p>
      <pre aria-label="Solidity-style signature verification sketch"><code>
               Slide 9 
    <section id="slide-9" class="slide panel" aria-labelledby="slide-9-title">
      <h2 id="slide-9-title" class="section-title">Slide 9 — Hands-On Exercise + Quiz</h2>
      <figure class="slide-figure">
        <img src="./img9.png" alt="Checklist for hybrid encryption exercise" />
        <figcaption>Practice: hybrid encryption and ECDSA verification.</figcaption>
      </figure>
      <p>
        In this guided exercise, you will combine symmetric and asymmetric primitives into a practical workflow. First, generate a random AES-256 key and encrypt a message with AES-GCM including AAD set to a context string (e.g., a user ID and timestamp). Second, generate an RSA key pair and encrypt the AES key using RSA-OAEP. Third, generate an EC key pair (secp256k1) and sign the SHA-256 hash of the ciphertext to create an authenticity proof. Finally, verify the signature and decrypt the symmetric key, then decrypt the message. This mirrors real-world flows where a dApp encrypts off-chain data, brokers access via asymmetric wrapping, and logs signed attestations for auditability.
      </p>
      <pre aria-label="Exercise scaffolding (Node.js)"><code>
               Slide 10 
    <section id="slide-10" class="slide panel" aria-labelledby="slide-10-title">
      <h2 id="slide-10-title" class="section-title">Slide 10 — Summary &amp; Further Reading</h2>
      <figure class="slide-figure">
        <img src="./img10.png" alt="Summary mind map for cryptography choices and hybrid flows" />
        <figcaption>Design playbook: asymmetric for identity and exchange; symmetric for speed and bulk confidentiality.</figcaption>
      </figure>
      <p>
        You now have a working mental model for symmetric and asymmetric cryptography, along with pragmatic Node.js patterns. Symmetric ciphers like AES-GCM deliver high-throughput confidentiality with built-in integrity. Asymmetric schemes like RSA and ECDSA solve identity, signatures, and secure key exchange. The hybrid pattern—negotiate with asymmetric, protect with symmetric—appears across messaging, content storage, and permissioned data access. In Web3, signatures are the user&rsquo;s authoritative consent mechanism; contracts and clients verify them without secrets. Keep security posture holistic: define key lifecycles, rotate keys, pin protocols and parameters, validate all inputs, and log verifications for auditability.
      </p>
      <h3 class="sub-title">Further Reading</h3>
      <ul>
        <li><a href="https://datatracker.ietf.org/doc/html/rfc5116" target="_blank" rel="noopener">RFC 5116 — AEAD: A Unified Construction</a></li>
        <li><a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank" rel="noopener">FIPS 197 — Advanced Encryption Standard (AES)</a></li>
        <li><a href="https://datatracker.ietf.org/doc/html/rfc8017" target="_blank" rel="noopener">RFC 8017 — RSA Cryptography Specifications (OAEP, PSS)</a></li>
        <li><a href="https://datatracker.ietf.org/doc/html/rfc7539" target="_blank" rel="noopener">RFC 7539 — ChaCha20 and Poly1305</a></li>
        <li><a href="https://eips.ethereum.org/EIPS/eip-712" target="_blank" rel="noopener">EIP-712 — Typed Structured Data Hashing and Signing</a></li>
      </ul>

      <details class="quiz">
        <summary>Final Quiz: Pick the right tool</summary>
        <div class="answer">
          - Encrypting a 10 MB file for storage: AES-256-GCM (symmetric).<br />
          - Sending the key to one recipient: RSA-OAEP or ECIES (asymmetric).<br />
          - Proving user consent to a contract: ECDSA signature (asymmetric).<br />
          - Streaming chat over P2P: Symmetric with rotating nonces and AAD per frame.
        </div>
      </details>

      <blockquote>
        Closing Note from MOKSHA Innovators Guild: Cryptography is our language of trust. Master these primitives and you will compose systems that are private by default, verifiable by design, and resilient under pressure. Onward, innovators.
      </blockquote>
    </section>
  </div>
</main>

 Footer 
<footer class="site-footer" role="contentinfo">
  © 2025 MOKSHA STUDIOS — Building the Future of Web3 Education
</footer>
